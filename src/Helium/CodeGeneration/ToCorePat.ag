ATTR Patterns 
    [   
    | 
    |   length : Int
    ]

ATTR Pattern Patterns
    [   
    | 
    |   vars USE { ++ } { [] } : { [(Name, TpScheme)] }
    ]

ATTR LeftHandSide Pattern Patterns
    [
    |
    |   patternTypes USE { M.union } { M.empty } : { M.Map Name Core.Type }
    ]

SEM Patterns
    | Cons lhs.length = 1 + @tl.length
    | Nil  lhs.length = 0
    

SEM Pattern
    | Variable              (loc.tpScheme, loc.coreType) = declarationTypeInPattern @lhs.fullTypeSchemes @lhs.importEnv @lhs.solveResult @name.self @lhs.betaDeclUnique
                            lhs.vars    = [ (@name.self, @loc.tpScheme) ]
                            lhs.patternTypes = M.singleton @name.self @loc.coreType
    --  range                    : Range
    --  name                     : Name

    | As                    (loc.tpScheme, loc.coreType) = declarationTypeInPattern @lhs.fullTypeSchemes @lhs.importEnv @lhs.solveResult @name.self @lhs.betaDeclUnique
                            lhs.vars    = (@name.self, @loc.tpScheme) : @pattern.vars
                            lhs.patternTypes = M.singleton @name.self $ findCoreType @lhs.solveResult @lhs.betaDeclUnique
    --  range                    : Range
    --  name                     : Name
    --  pattern                  : Pattern

{

patternAlwaysSucceeds :: Pattern -> Bool
patternAlwaysSucceeds p = 
    case p of
        Pattern_Variable _ _ -> True
        Pattern_Wildcard _ -> True
        Pattern_As _ _ pat -> patternAlwaysSucceeds pat
        Pattern_Parenthesized _ pat -> patternAlwaysSucceeds pat
        _ -> False

patternMatchFail :: String -> Core.Type -> Range -> Core.Expr
patternMatchFail nodeDescription tp range =
    Core.ApType (var "$primPatternFailPacked") tp
        `app_` packedString (
                    nodeDescription ++ " ranging from " ++ 
                    showPosition start ++ " to " ++ 
                    showPosition (getRangeEnd range) ++ " in module " ++
                    moduleFromPosition start
               )
    where
        start = getRangeStart range
}
