-- ------------------------------------------------------------------------
-- -- Modules                                                            --
-- ------------------------------------------------------------------------

imports{
import Lvm.Common.Byte(bytesFromString)
}

{
makeCoreModule :: Maybe Id -> [Module.Decl v] -> Module.Module v
makeCoreModule name decls =
    Module.Module
        { Module.moduleName   =
            case name of
                Nothing -> idFromString "Main"
                Just n -> n
        , Module.moduleMajorVer = 0
        , Module.moduleMinorVer = 0
        , Module.moduleImports  = []
        , Module.moduleDecls    = decls
        }

interpreterMain :: String
interpreterMain = "interpreter_main"

-- Unfortunately we need a hack for the interpreter
-- The interpreter_main has te be wrapped inside unsafePerformIO etcetera, too
-- We can't just call it main because we'll get import clashes.  Sigh!

insertedMain :: ImportEnvironment -> String -> TypeEnvironment -> Maybe CoreDecl
insertedMain env moduleName toplevelTypes = 
    let tse = typeSynonyms env
        classEnv = classEnvironment env
        maybeWrapMainAndType = 
            case (M.lookup (Name_Identifier noRange [] [] "main") $! toplevelTypes) of -- !!!Name
                Just t -> Just (moduleName ++ ".main", t)
                Nothing ->
                    case (M.lookup (Name_Identifier noRange [] [] interpreterMain) $! toplevelTypes) of -- !!!Name
                        Just t -> Just (interpreterMain, t)
                        Nothing -> Nothing
        d tp expr = Just $ decl False "real_main" tp $ app_ (Core.ApType unsafePIO tp) expr
    in
        case maybeWrapMainAndType of 
            Nothing ->
                Nothing
            Just (name, tpScheme)
                | not (null qs) ->
                    d (Core.TCon $ Core.TConTuple 0) $ var "LvmLang.putStrLn" `app_`
                        (var "$primPackedToString" `app_`
                            packedString "<<overloaded function>>")
                | isJust (isIOType tp) -> 
                    d (typeToCoreType $ fromJust $ isIOType tp) $ var name
                | otherwise ->
                    d (Core.TCon $ Core.TConTuple 0) $ var "LvmLang.putStrLn" `app_`
                        (Core.Ap (var "show" `Core.ApType` typeToCoreType tp) (DerivingUtils.eqFunForType "Prelude.Show$" tse M.empty (makeTypeFromTp tp)) `app_`
                            var name)
                where                        
                    (qs, tp) = split (snd (instantiate 123456789 tpScheme))
    where
        unsafePIO = var "$primUnsafePerformIO"    
                
}

SEM Module
    | Module    -- insert "insertedMain" after modulePublic so that it remains private
                lhs.core = @module_ { Module.moduleDecls = 
                                (maybe id (:) $ insertedMain @lhs.importEnv @loc.modulename @lhs.toplevelTypes) $ Module.moduleDecls @module_ }
                loc.modulename = maybe "Main" getNameName @name.name
                loc.moduleQual = maybe ["Main"] getQualified @name.name
                loc.module_ = 
                    setExportsPublic @exports.isImplicit @loc.exportlists @lhs.importEnv
                        (makeCoreModule (Just $ idFromString @modulename)
                            ( @body.decls
                            ))
                body . instanceName = Nothing
                loc.exportlists = (@exports.values
                                  , @exports.confieldormethods
                                  , @exports.typeorclasses
                                  , @exports.typeorclassesCompl
                                  , @exports.modules)
    --  range                    : Range
    --  name                     : MaybeName
    --  exports                  : MaybeExports
    --  body                     : Body

{
-- set the public bit of all declarations except those that are imported from
-- Prelude or HeliumLang. I.e. export everything everywhere
everythingPublicButPrelude :: Core.CoreModule -> Core.CoreModule
everythingPublicButPrelude theModule = theModule { Core.moduleDecls = map setPublic (Core.moduleDecls theModule) }
  where
    setPublic declaration =
        let -- accessRecord = Core.declAccess decl
            public = Core.declModule declaration `notElem` [Just $ idFromString "Prelude", Just $ idFromString "HeliumLang"]
        in
        declaration{ Core.declAccess = if public then Core.Export $ Core.declName declaration else Core.Private }

-- Set all imported modules to private, and export the normal declarations.
everythingPublicButImported :: Core.CoreModule -> Core.CoreModule
everythingPublicButImported theModule = theModule { Core.moduleDecls = map setPublic (Core.moduleDecls theModule) }
  where
    setPublic declaration =
        let -- accessRecord = Core.declAccess decl
            -- TODO: Why do we also export declarations from PreludePrim?
            public = Core.declModule declaration `elem` [Nothing, Just $ idFromString "PreludePrim"]
        in
        declaration{ Core.declAccess = if public then Core.Export $ Core.declName declaration else Core.Private }
}

{-
{
-- Return all local value definitions that start with a '$' in the name
localValuePrims :: [CoreDecl] -> IdSet
localValuePrims cdecls
  = setFromList [declName decl  | decl <- cdecls
                                , isDeclValue decl
                                , let name = stringFromId (declName decl)
                                , not (null name)
                                , head name == '$'
                                ]
                      
}
-}
    --  range                    : Range
    --  name                     : MaybeName
    --  exports                  : MaybeExports
    --  body                     : Body
-- Since the parser cannot distinguish between types or constructors,
-- or between types and type classes, we do not have different cases (yet?).

ATTR Declarations Declaration
    [   isTopLevel : Bool
    |
    |
    ]   
    
ATTR MaybeExports[|| isImplicit : Bool]

SEM MaybeExports
    | Nothing lhs.isImplicit = True
    | Just    lhs.isImplicit = False

ATTR MaybeExports Export Exports
    [
    |
    | values, typeorclasses, confieldormethods, typeorclassesCompl, modules USE { `unionSet` } { emptySet } : {IdSet}
    ]

SEM Export
    | Variable               lhs.values             = singleSet (idFromName @name.self)
    --  range                    : Range
    --  name                     : Name
    | TypeOrClass            lhs.typeorclasses      = singleSet (idFromName @name.self)
                                .confieldormethods  = setFromList (maybe [] (map idFromName) @names.names)
    --  range                    : Range
    --  name                     : Name
    --  names                    : MaybeNames  -- constructors or field names or class methods
    | TypeOrClassComplete    lhs.typeorclassesCompl = singleSet (idFromName @name.self)
    --  range                    : Range
    --  name                     : Name
    | Module                 lhs.modules            = singleSet (idFromName @name.self)
    --  range                    : Range
    --  name                     : Name   -- this is a module name

ATTR Body Declarations Declaration MaybeDeclarations
    [   moduleQual : { [String] }
    | 
    |   decls USE { ++ } { [] } : { [CoreDecl] }
    ]

ATTR Constructors Constructor
    [ moduleQual : { [String] } | | ]

SEM Body
    | Body             lhs.decls    = @declarations.decls
                       declarations.patBindNr = 0
                       declarations.instanceName = Nothing
    --  range                    : Range
    --  importdeclarations       : ImportDeclarations
    --  declarations             : Declarations
