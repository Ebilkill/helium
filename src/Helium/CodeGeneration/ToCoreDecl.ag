-- ------------------------------------------------------------------------
-- -- Declarations                                                       --
-- ------------------------------------------------------------------------

ATTR Declaration Declarations [ | patBindNr : Int | ]
ATTR MaybeDeclarations [ | | whereDeclarations : {[(Name, CoreDecl)]}]

ATTR Declaration Declarations MaybeDeclarations [ 
        typeClassContext : TypeClassContext
    |  
    |   functionNames USE {(++)} {[]}: {[Name]} 
        declNames USE {(++)} {[]}: {[Name]}
        collectDefaults USE {(++)} {[]} : {[(Name, CoreDecl)]}
    ]
      
SEM Body
    | Body
        declarations.typeClassContext = TCCNone

SEM Expression
    | Let
        declarations.typeClassContext = TCCNone

SEM Qualifier
    | Let
        declarations.typeClassContext = TCCNone

SEM Statement
    | Let
        declarations.typeClassContext = TCCNone

SEM MaybeDeclarations [ | |   core : { Core.Expr -> Core.Expr } ]
    | Nothing     lhs.core = \continue -> continue
                  lhs.whereDeclarations = []
    | Just        declarations.patBindNr = 0
                  declarations.isTopLevel = False
                  declarations.importEnv = @lhs.importEnv
                  lhs.whereDeclarations = zip @declarations.declNames @declarations.decls
                  lhs.core = \continue -> letrec_ @declarations.decls continue  

SEM Declaration          
    | Type  
            lhs.decls  =
        let -- if we would have the collected type synonym information here, things could have been
            -- done much easier.
            (t1,[t2])   = convertFromSimpleTypeAndTypes @simpletype.self [@type.self]
            allTypeVars = ftv [t1,t2]
            (ts1,ts2)   = ( Quantification (allTypeVars, [], [] .=>. t1) :: TpScheme
                          , Quantification (allTypeVars, [], [] .=>. t2) :: TpScheme
                          )
        in
        [ Core.DeclCustom
            { Core.declName    = idFromString (getNameName @simpletype.name)
            , Core.declAccess  = Core.private
            , Core.declKind    = Core.DeclKindCustom (idFromString "typedecl")
            , Core.declCustoms =
                [ Core.CustomBytes
                    (Byte.bytesFromString
                        (  show ts1
                        ++ " = "
                        ++ show ts2
                        )
                    )
                , Core.CustomInt
                    (length @simpletype.typevariables)
                ]
            }
        ]
        ++
        [ DerivingShow.typeShowFunction (classEnvironment @lhs.importEnv) (typeSynonyms @lhs.importEnv) @self ]
    
    | Data    constructors.dataTypeName = @simpletype.name
              constructors.dataTypeCoreType = @simpletype.coreType
              constructors.typevariables = @simpletype.typevariables
              lhs.decls  =
        map snd @constructors.cons
        ++
        [ Core.DeclCustom
            { Core.declName    = idFromString (getNameName @simpletype.name)
            , Core.declAccess  = Core.private
            , Core.declKind    = Core.DeclKindCustom (idFromString "data")
            , Core.declCustoms = [Core.CustomInt (length @simpletype.typevariables)]
            }
        ] ++ 
        (if "Show" `elem` map show @derivings.self 
         then [ DerivingShow.dataDictionary (classEnvironment @lhs.importEnv) (typeSynonyms @lhs.importEnv) @self ]
         else []
        )
        ++
        (if "Eq" `elem` map show @derivings.self 
         then [ DerivingEq.dataDictionary @self ]
         else []
        )
        
    --  range                    : Range        
    --  context                  : ContextItems
    --  simpletype               : SimpleType
    --  constructors             : Constructors
    --  derivings                : Names
    
    | FunctionBindings  
                        (bindings.quantorMap, loc.declType) = declarationType @lhs.fullTypeSchemes @lhs.importEnv @lhs.typeClassContext @lhs.quantorMap @bindings.name
                        loc.ids      = freshIds "u$" @bindings.arity
                        bindings.ids = @loc.ids
                        bindings.range = @range.self
                        lhs.declNames = [@bindings.name]
                        loc.instanceDict = [idFromString $ "$instanceDict" ++ show name | Just name <- [@lhs.instanceName]]
                        loc.dictionaries = @instanceDict ++ (map predicateToId (getPredicateForDecl @bindings.name @lhs.dictionaryEnv))
                        lhs.decls    =  
        [ Core.DeclValue
            { Core.declName    = idFromName @bindings.name
            , Core.declAccess  = Core.private
            , Core.declType    = @loc.declType
            , Core.valueValue  = addLambdas @lhs.fullTypeSchemes @lhs.importEnv @lhs.typeClassContext @lhs.quantorMap @bindings.name (@dictionaries ++ @ids) @bindings.core
            , Core.declCustoms = toplevelType @bindings.name @lhs.importEnv (@lhs.isTopLevel || isJust @lhs.instanceName)
            }
        ]
    --  range                    : Range          
    --  bindings                 : FunctionBindings -- should all be for the same function
    
    | PatternBinding    lhs.patBindNr = @lhs.patBindNr + 1
                        loc.dictionaries = 
                            case @pattern.self of
                                Pattern_Variable _ n ->
                                   map predicateToId 
                                      (getPredicateForDecl n @lhs.dictionaryEnv)
                                _ -> []
                        -- TODO: Set quantorMap                   
                        lhs.decls     = 
        case  @pattern.self of
            Pattern_Variable _ n ->
                [ Core.DeclValue
                    { Core.declName    = idFromName n
                    , Core.declAccess  = Core.private
                    , Core.declType    = snd $ declarationType @lhs.fullTypeSchemes @lhs.importEnv @lhs.typeClassContext @lhs.quantorMap n
                    , Core.valueValue  =
                        addLambdas @lhs.fullTypeSchemes @lhs.importEnv @lhs.typeClassContext @lhs.quantorMap n @dictionaries
                            (\_ -> let_ -- because guards can fail
                                nextClauseId Core.typeUndefined (patternMatchFail "pattern binding" @range.self)
                                @righthandside.core
                            )
                    , Core.declCustoms = toplevelType n @lhs.importEnv @lhs.isTopLevel
                    }
               ]
            _ -> 
              let patBindTp = Core.TAny
              in Core.DeclValue
                    { Core.declName    = patBindId
                    , Core.declAccess  = Core.private
                    , Core.declType    = patBindTp
                    , Core.valueValue  =
                        let_ 
                            nextClauseId patBindTp (patternMatchFail "pattern binding" @range.self)
                            @righthandside.core
                    , Core.declCustoms = [custom "type" "patternbinding"]
                    }
                :
                [ Core.DeclValue
                    { Core.declName    = idFromName v
                    , Core.declAccess  = Core.private
                    , Core.declType    = tp
                    , Core.valueValue  =
                        (let_ nextClauseId tp (patternMatchFail "pattern binding" @range.self)
                            (patternToCore @lhs.importEnv @pattern.patternTypes (patBindId, patBindTp, @pattern.self) (Core.Var (idFromName v)))
                        )
                    , Core.declCustoms = toplevelType v @lhs.importEnv @lhs.isTopLevel
                    }
                | v <- @pattern.vars,
                  let tp = snd $ declarationType @lhs.fullTypeSchemes @lhs.importEnv @lhs.typeClassContext @lhs.quantorMap v
                ]
                where 
                    patBindId = idFromString ("patBind$" ++ show @lhs.patBindNr)
    --  range                    : Range
    --  pattern                  : Pattern
    --  righthandside            : RightHandSide
    
    | TypeSignature         lhs.decls    = []
                            lhs.functionNames = @names.self    
    --  range                    : Range
    --  names                    : Names
    --  type                     : Type   -- may have context
    
    | Fixity            lhs.decls    =
        map
            ( ( \n ->
                Core.DeclCustom
                    { Core.declName    = idFromString n
                    , Core.declAccess  = Core.private
                    , Core.declKind    = (Core.DeclKindCustom . idFromString) "infix"
                    , Core.declCustoms =
                        [ Core.CustomInt 
                             ( case @priority.self of
                                  MaybeInt_Just i  -> i
                                  MaybeInt_Nothing -> 9 )
                        , (Core.CustomBytes . bytesFromString)
                              ( case @fixity.self of
                                   Fixity_Infixr _ -> "right"
                                   Fixity_Infixl _ -> "left"
                                   Fixity_Infix  _ -> "none"
                            --       _               -> internalError
                            --                            "ToCoreDecl.ag"
                            --                            "SEM Declaration.Fixity"
                            --                            "unknown fixity"
                              )
                        ]
                    }
              )
              . 
              getNameName
            )
            @operators.self
    --  range                    : Range
    --  fixity                   : Fixity
    --  priority                 : MaybeInt
    --  operators                : Names
    | Class             loc . superClasses = getSuperClasses @context.self
                        lhs.decls    = let 
                                            isInfix (Module.DeclCustom{
                                                Core.declKind = (Core.DeclKindCustom n)
                                            }) = stringFromId n `isSuffixOf` " infix"
                                            isInfix _ = False
                                        in (classFunctions @lhs.importEnv @lhs.fullTypeSchemes (getNameName @simpletype.name) (getNameName $ head @simpletype.typevariables) $ constructFunctionMap @lhs.importEnv (length @superClasses) @simpletype.name) ++ 
                                        [
                                            Core.DeclCustom
                                                {
                                                    Core.declName = idFromName @simpletype.name,
                                                    Core.declAccess = Core.public,
                                                    Core.declKind = Core.DeclKindCustom $ idFromString "ClassDefinition",
                                                    Core.declCustoms = constructClassMemberCustomDecl @lhs.importEnv @simpletype.name (M.lookup @simpletype.name $ classMemberEnvironment @lhs.importEnv)
                                                }
                                        ] ++ convertDictionaries @lhs.importEnv @lhs.fullTypeSchemes @simpletype.name @where.functionNames @where.whereDeclarations 
                                         ++ (filter isInfix @where.decls)
                        where . instanceName = Just @simpletype.name
                        where . typeClassContext = TCCClass
                        where . dictionaryEnv = setCurrentClassNames (zip @where.functionNames (repeat ("$instanceDict" ++ show @simpletype.name))) @lhs.dictionaryEnv
    | Instance          lhs .   decls    =  [ constructDictionary 
                                                @lhs.importEnv
                                                (getSuperClasses @context.self)
                                                (constructFunctionMap @lhs.importEnv (length @superClasses) @name.self)
                                                @where.whereDeclarations @name.self @loc.typeName (namesInType @loc.type)
                                                (typeToCoreType @lhs.quantorMap $ makeTpFromType @typevariables @type)
                                            ] 
                        loc .   typeName = showInstanceType $ makeTpFromType @typevariables @type
                        loc .   err = error $ "Invalid class name " ++ getNameName @name.self
                        loc .   superClasses = fst (fromMaybe @err (M.lookup (getNameName @name.self) (classEnvironment @lhs.importEnv)))
                        loc .   typevariables = zip (namesInType @loc.type) [TVar n | n <- [0..]]
                        loc .   type = head @types.self
                        where . instanceName = Just @name.self
                        where . typeClassContext = TCCInstance (idFromName @name.self) (toCoreTypeNotQuantified $ makeTpSchemeFromType @loc.type)
    
    -- Not supported
    
    | Newtype           lhs.decls    = internalError "ToCoreDecl" "Declaration" "'newType' not supported"
                        constructor.dataTypeName = @simpletype.name
                        constructor.dataTypeCoreType = @simpletype.coreType
                        constructor.typevariables = @simpletype.typevariables
    --  range                    : Range
    --  context                  : ContextItems
    --  simpletype               : SimpleType
    --  constructor              : Constructor  -- has only one field, no strictness
    --  derivings                : Names
    
    
    | Default           lhs.decls    = internalError "ToCoreDecl" "Declaration" "'default' not supported"
    --  range                    : Range
    --  types                    : Types        -- should be instances of Num
    
    | Empty             lhs.decls    = internalError "ToCoreDecl" "Declaration" "empty declarations not supported"
    --  range                    : Range

ATTR FunctionBinding FunctionBindings 
    [   ids : { [Id] }
    | 
    |   arity : Int
    ]

SEM FunctionBindings [ range : Range | | core : {[Core.Type] -> Core.Expr}  ]
    | Cons             lhs.core  = \tps -> @hd.core tps $ @tl.core tps
                          .arity = @hd.arity
    | Nil              lhs.core  = \_ -> patternMatchFail "function bindings" @lhs.range
                          .arity = internalError "ToCoreDecl" "FunctionBindings" "arity: empty list of function bindings"

SEM FunctionBinding [ | | core : { [Core.Type] -> Core.Expr -> Core.Expr } ]
    | Hole             lhs.arity = 0
                          . core = internalError "ToCoreDecl" "FunctionBinding" "holes not supported"
    | FunctionBinding  lhs.arity = @lefthandside.arity
                       lhs.core = 
        \tps nextClause ->
            let thisClause = 
                    patternsToCore
                        @lhs.importEnv
                        @lefthandside.patternTypes
                        (zip3 @lhs.ids tps @lefthandside.patterns)
                        @righthandside.core in
            if all patternAlwaysSucceeds @lefthandside.patterns 
               &&
               not @righthandside.isGuarded
            then
                thisClause
            else
                let_ nextClauseId Core.TAny nextClause thisClause
                                      
    --  range                    : Range
    --  lefthandside             : LeftHandSide
    --  righthandside            : RightHandSide
{

getSuperClasses ::  ContextItems -> [(String, Name)]
getSuperClasses = map (\(ContextItem_ContextItem _ n vs) -> (getNameName n, var vs))
    where
        var [vs] = name $ namesInType vs
        var _ = error "Type variable not a single type"
        name [n] = n
        name _ = error "Type variable not a single name"

predicateToId :: Predicate -> Id
predicateToId (Predicate class_ tp) =
    idFromString $ "$dict" ++ class_ ++ "$" ++ show tp
    
dictionaryTreeToCore :: DictionaryTree -> Core.Expr
dictionaryTreeToCore theTree =
   case theTree of
        ByPredicate predicate -> 
            Core.Var (predicateToId predicate)
        ByInstance className instanceName trees ->
            foldl Core.Ap
                (Core.Var (idFromString ("$dict"++className++ "$" ++ instanceName)))
               (map dictionaryTreeToCore trees)
        BySuperClass subClass superClass tree -> 
            Core.Ap (Core.Var (idFromString ("$get" ++ superClass ++ "$" ++ subClass)))          
                 (dictionaryTreeToCore tree)
        ByCurrentClass className ->
            Core.Var (idFromString $ "$instanceDict" ++ className)
        BySuperInstance p className typeVariables -> 
            Core.Var (idFromString $ "$instanceDict" ++ className ++ "$" ++ typeVariables )
    

insertDictionaries :: Name -> DictionaryEnvironment -> Core.Expr
insertDictionaries name dictionaryEnv = 
   foldl Core.Ap
         (Core.Var (idFromName name))
         ((map dictionaryTreeToCore (getDictionaryTrees name dictionaryEnv)))
}

ATTR LeftHandSide 
    [ 
    | 
    |   arity : Int
        patterns : Patterns
    ]

SEM LeftHandSide
    | Function         lhs.arity = @patterns.length
                          .patterns = @patterns.self
    --  range                    : Range
    --  name                     : Name
    --  patterns                 : Patterns

    | Infix            lhs.arity = 2
                          .patterns = [@leftPattern.self, @rightPattern.self ]
    --  range                    : Range
    --  leftPattern              : Pattern
    --  operator                 : Name
    --  rightPattern             : Pattern

    | Parenthesized    lhs.arity = @lefthandside.arity + @patterns.length
                          .patterns = @lefthandside.patterns ++ @patterns.self
    --  range                    : Range
    --  lefthandside             : LeftHandSide
    --  patterns                 : Patterns

SEM RightHandSide
    [ 
    | 
    |   core : { Core.Expr } 
        isGuarded : Bool
    ]

    | Expression        lhs.core = @where.core @expression.core
                            .isGuarded = False
                        where.instanceName = Nothing
                        where.typeClassContext = TCCNone
    --  range                    : Range
    --  expression               : Expression
    --  where                    : MaybeDeclarations

    | Guarded         lhs.isGuarded = True
                         .core = @where.core (foldr ($) (Core.Var nextClauseId) @guardedexpressions.core)
                    where.instanceName = Nothing
                    where.typeClassContext = TCCNone
                         
    --  range                    : Range
    --  guardedexpressions       : GuardedExpressions
    --  where                    : MaybeDeclarations

-- ------------------------------------------------------------------------
-- -- Types                                                              --
-- ------------------------------------------------------------------------

ATTR Constructors Constructor 
    [
    | 
    |   cons USE { ++ } { [] } : { [(Id, CoreDecl)] } 
    ]

SEM Constructors [ dataTypeName : Name typevariables : Names dataTypeCoreType : { Core.Type } | | ]

SEM Constructor [ dataTypeName : Name typevariables : Names dataTypeCoreType : { Core.Type } | | ]
    | Constructor       lhs.cons = 
        [ (idFromName @constructor.self, Core.DeclCon
            { Core.declName    = idFromName @constructor.self
            , Core.declAccess  = Core.private
            , Core.declType    = foldr (`Core.TForall` Core.KStar) (Core.typeFunction @types.coreTypes @lhs.dataTypeCoreType) $ map idFromName @lhs.typevariables
            , Core.declCustoms = constructorCustoms 
                                    @lhs.dataTypeName
                                    @constructor.self 
                                    (valueConstructors @lhs.importEnv)
            }
          )
        ]
    --  range                    : Range
    --  constructor              : Name
    --  types                    : AnnotatedTypes
    
    | Infix             lhs.cons = 
        [ (idFromName @constructorOperator.self, Core.DeclCon
            { Core.declName    = idFromName @constructorOperator.self
            , Core.declAccess  = Core.private
            , Core.declType    = foldr (`Core.TForall` Core.KStar) (Core.typeFunction [@leftType.coreType, @rightType.coreType] @lhs.dataTypeCoreType) $ map idFromName @lhs.typevariables
            , Core.declCustoms = constructorCustoms
                                    @lhs.dataTypeName
                                    @constructorOperator.self 
                                    (valueConstructors @lhs.importEnv)
            }
          )
        ]
    --  range                    : Range
    --  leftType                 : AnnotatedType
    --  constructorOperator      : Name
    --  rightType                : AnnotatedType
    
-- Not supported

    | Record            lhs.cons = internalError "ToCoreDecl" "Constructor" "records not supported"
    --  range                    : Range
    --  constructor              : Name
    --  fieldDeclarations        : FieldDeclarations

SEM AnnotatedTypes [ typevariables : Names | | coreTypes : { [Core.Type] } ]
    | Cons lhs.coreTypes = @hd.coreType : @tl.coreTypes
    | Nil  lhs.coreTypes = []

SEM AnnotatedType [ typevariables : Names | | coreType : { Core.Type } ]
    | AnnotatedType lhs.coreType =
        let
            tp = toCoreTypeNotQuantified $ makeTpSchemeFromType @type.self
        in if @strict then Core.TStrict tp else tp
{
constructorCustoms :: Name -> Name -> ValueConstructorEnvironment -> [Core.Custom]
constructorCustoms dataTypeName name env =
    maybe 
        (internalError "ToCoreDecl" "Constructor" ("no type found for " ++ show name))
        (\tpScheme -> 
            [ custom "type" (show tpScheme)
            , Core.CustomLink 
                    (idFromName dataTypeName) 
                    (Core.DeclKindCustom (idFromString "data"))
            ]
        )
        (M.lookup name env)
}
