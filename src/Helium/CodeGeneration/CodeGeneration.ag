ATTR Module
   [   dictionaryEnv    : DictionaryEnvironment
       extraDecls       : { [Core.CoreDecl] }
       importEnv        : ImportEnvironment
       toplevelTypes    : TypeEnvironment
   |
   |   core             : { Core.CoreModule }
   ]

ATTR Module Body Declaration Declarations MaybeDeclarations
  Expression Expressions MaybeExpression
  Statements Statement Qualifiers Qualifier Alternatives Alternative
  GuardedExpressions GuardedExpression RecordExpressionBindings
  RecordExpressionBinding RecordPatternBindings RecordPatternBinding
  FunctionBindings FunctionBinding LeftHandSide RightHandSide
  Patterns Pattern [ fullTypeSchemes : { M.Map NameWithRange TpScheme } solveResult : { SolveResult ConstraintInfo } | | ]

-- UHA
INCLUDE "UHA_Syntax.ag"

-- Type variables to recover type information from constraint solver output
INCLUDE "../StaticAnalysis/Inferencers/TypeInferenceDeclTypeVar.ag"

-- Transformation into Core
INCLUDE "ToCoreModule.ag"
INCLUDE "ToCoreDecl.ag"
INCLUDE "ToCoreExpr.ag"
INCLUDE "ToCorePat.ag"
INCLUDE "ToCoreName.ag"

imports{
import Helium.Syntax.UHA_Syntax
import Helium.Syntax.UHA_Utils
import Helium.Syntax.UHA_Range 
import Helium.ModuleSystem.ImportEnvironment
import Helium.ModuleSystem.DictionaryEnvironment
import qualified Data.Map as M
import Helium.StaticAnalysis.Miscellaneous.TypeConversion
import Data.Char (ord)
import Data.Maybe
import Data.List(isSuffixOf)

import Helium.CodeGeneration.InstanceDictionary

import Lvm.Common.Id
import Lvm.Common.IdSet 
import Helium.Utils.Utils(internalError)

import Top.Types
import Top.Solver (SolveResult)
import Helium.StaticAnalysis.Miscellaneous.ConstraintInfo (ConstraintInfo)

import Helium.CodeGeneration.PatternMatch
import qualified Helium.CodeGeneration.DerivingShow as DerivingShow
import qualified Helium.CodeGeneration.DerivingEq as DerivingEq

-- Semi-Daan
import Helium.CodeGeneration.CoreUtils

-- Daan
import qualified Lvm.Core.Expr as Core
import qualified Lvm.Core.Type as Core
import qualified Lvm.Core.Module as Core
import qualified Lvm.Core.Module as Module
import qualified Lvm.Common.Byte as Byte
}

{

type CoreDecl = Core.Decl Core.Expr
}

--Collect.ag

ATTR Body Declarations Declaration Expressions Expression Statements Statement
     Qualifiers Qualifier GuardedExpressions GuardedExpression 
     Alternatives Alternative FunctionBindings FunctionBinding
     RightHandSide MaybeDeclarations MaybeExpression RecordExpressionBinding
     RecordExpressionBindings Constructors Constructor
    [ dictionaryEnv : DictionaryEnvironment
        instanceName : {Maybe Name} 
        importEnv : ImportEnvironment
        | | ]

ATTR SimpleType [ | | name:Name typevariables:Names coreType: {Core.Type} ]

SEM SimpleType
  | SimpleType  lhs . name          = @name.self                   
                    . typevariables = @typevariables.self
                    . coreType = foldl Core.TAp (Core.TCon $ Core.TConDataType $ idFromName @name.self) $ map (Core.TVar . idFromName) @typevariables.self
