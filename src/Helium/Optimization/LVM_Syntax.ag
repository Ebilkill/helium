------------
-- Imports --
------------
imports{
import Helium.Optimization.Annotations
import Helium.Optimization.Datas(DataAnns, emptyDataAnns, singletonDataAnns, singletonDataCon, unionDataAnns)
import Helium.Optimization.Show()
import Helium.Optimization.Types
import Helium.Optimization.Utils

import Data.Map(Map)
import qualified Data.Map as Map
import qualified Data.Maybe as M
import Data.Char(isLower)

import qualified Helium.ModuleSystem.CoreToImportEnv as C
import Helium.Utils.Utils

import qualified Lvm.Common.Byte as B
import qualified Lvm.Common.Id as I
import qualified Lvm.Core.Expr as Expr
import qualified Lvm.Core.Module as Module

import qualified Top.Types as T
import qualified Top.Types.Synonym as Syn
}

------------
-- Module --
------------
DERIVING OptimizeModule Decl Expr Binds Bind Alt Pat Literal : Show
DATA OptimizeModule
    | Module
        name                    : {I.Id}
        majorV                  : {Int}
        minorV                  : {Int}
        decls                   : Decls

TYPE Decls                      = [ Decl ]

DATA Decl
    | Start
        name                    : {I.Id}
        access                  : {Module.Access}
        encoding                : {M.Maybe I.Id}
        expr                    : Expr
    | Function
        name                    : {I.Id}
        access                  : {Module.Access}
        encoding                : {M.Maybe I.Id}
        expr                    : Expr
        customs                 : {[Module.Custom]}
        ty                      : {T.TpScheme}
    | Abstract
        name                    : {I.Id}
        access                  : {Module.Access}
        arity                   : {Module.Arity}
        customs                 : {[Module.Custom]}
        ty                      : {T.TpScheme}
    | Constructor
        name                    : {I.Id}
        access                  : {Module.Access}
        arity                   : {Module.Arity}
        tag                     : {Module.Tag}
        customs                 : {[Module.Custom]}
        datalink                : {I.Id}
        ty                      : {T.TpScheme}
    | Data
        name                    : {I.Id}
        access                  : {Module.Access}
        kind                    : {Module.DeclKind}
        customs                 : {[Module.Custom]}
        typeKind                : {Int}
    | Synonym
        name                    : {I.Id}
        access                  : {Module.Access}
        kind                    : {Module.DeclKind}
        customs                 : {[Module.Custom]}
        tpSynonym               : {Synonym}
    | Custom
        name                    : {I.Id}
        access                  : {Module.Access}
        kind                    : {Module.DeclKind}
        customs                 : {[Module.Custom]}
        -- Contains: Infix & Strategy and possibly more

----------
-- Expr --
----------

DATA Expr
    | Let
        binds                   : Binds
        expr                    : Expr
        t                       : {Maybe T}
    | Match
        name                    : {I.Id}
        alts                    : Alts
        t                       : {Maybe T}
    | Ap
        expr1                   : Expr
        expr2                   : Expr
        t                       : {Maybe T}
    | Lam
        name                    : {I.Id}
        expr                    : Expr
        t                       : {Maybe T}
    | ConId
        name                    : {I.Id}
        t                       : {Maybe T}
    | ConTag
        expr                    : Expr
        arity                   : {Module.Arity}
        t                       : {Maybe T}
    | Var
        name                    : {I.Id}
        t                       : {Maybe T}
    | Lit
        lit                     : Literal
        t                       : {Maybe T}

-- Let bindings
DATA Binds
    | Rec
        binds                   : Binds'
    | NonRec
        bind                    : Bind
    | Strict
        bind                    : Bind

TYPE Binds'                     = [ Bind ]

DATA Bind
    | Bind
        name                    : {I.Id}
        expr                    : Expr
        ts                      : {Maybe Ts}

-- Guard alternatives
TYPE Alts                       = [ Alt ]

DATA Alt
    | Alt
        pat                     : Pat
        expr                    : Expr

DATA Pat
    | ConId
        name                    : {I.Id}
        ids                     : {[I.Id]}
    | ConTag
        tag                     : {Module.Tag}
        arity                   : {Module.Arity}
        ids                     : {[I.Id]}
    | Lit
        lit                     : Literal
    | Default

-- Typed literals
DATA Literal
    | LitInt
        int_                    : {Int}
    | LitDouble
        double_                 : {Double}
    | LitBytes
        bytes_                  : {B.Bytes}

-----------------
-- Type Module --
-----------------
{
defaultSyn :: Map I.Id Synonym -> Map I.Id Synonym -- adds { String = [Char] } and { PackedString = Bytes }
defaultSyn = Map.union $ Map.fromList
    [ ((I.idFromString "String"), (Synonym $ C.typeSynFromCustoms (show "String") [(Module.CustomBytes (B.bytesFromString "String = [Char]")), Module.CustomInt 0]))
    , ((I.idFromString "PackedString"),(Synonym $ C.typeSynFromCustoms (show "PackedString") [(Module.CustomBytes (B.bytesFromString "PackedString = Bytes")), Module.CustomInt 0]))
    ]
}

ATTR OptimizeModule [ | | ct USE {++} {[]} : { Constraints } showIt : {[(String, Ts, T.TpScheme)]} optimizeModule : OptimizeModule ]
SEM OptimizeModule
    | Module        decls.uniqueId = 0
                    decls.syn = defaultSyn $ @decls.genSyn --}trace ("Module : " ++ I.stringFromId @name ++ " : Syn : " ++ show @decls.genSyn) @decls.genSyn
                    decls.data = @decls.genData
                    decls.dataKind = @decls.genDataKind
                    decls.cons = @decls.genCons
                    decls.env = @decls.genEnv --}trace ("Module : " ++ I.stringFromId @name ++ " : Env : " ++ show @decls.genEnv) @decls.genEnv
                    loc.solved = runFreshFrom @decls.uniqueId $ solveConstraints @decls.ct
                    loc.uniqueId = snd $ @loc.solved -- the next free id
                    decls.sub = fst $ (\t -> trace ("decls.sub:" ++ ((\(Sub subt subts subann) -> "Sub " ++ show (Map.size subt) ++ " " ++ show (Map.size subts) ++ " " ++ show (Map.size subann)) $ fst t) ++ ":ct:" ++ show (snd t)++ " <= decls.ct:" ++ show @decls.ct) t) $ (\t -> trace ("decls.sub:" ++ ((\(Sub subt subts subann) -> "Sub " ++ show (Map.size subt) ++ " " ++ show (Map.size subts) ++ " " ++ show (Map.size subann)) $ fst t) ++ ":ct:" ++ show (length $ snd t) ++ " <= decls.ct:" ++ show (length @decls.ct)) t) $ fst $ @loc.solved
                    lhs.optimizeModule = OptimizeModule_Module @name @majorV @minorV @decls.decls


ATTR Decls Decl [ syn : {Map I.Id Synonym}
                  data : {DataAnns}
                  dataKind : {Map I.Id Int}
                  cons : {DataAnns}
                  env : {Env}
                  sub : {Sub}
                | uniqueId : {Int}
                | genSyn USE {Map.union} {Map.empty} : {Map I.Id Synonym}
                  genData USE {unionDataAnns} {emptyDataAnns} : {DataAnns}
                  genDataKind USE {Map.union} {Map.empty} : {Map I.Id Int}
                  genCons USE {unionDataAnns} {emptyDataAnns} : {DataAnns}
                  genEnv USE {union} {empty} : {Env}
                  ct USE {++} {[]} : { Constraints }
                  showIt USE {++} {[]} : {[(String, Ts, T.TpScheme)]}
                ]

ATTR Decls [ | | decls : Decls ]

SEM Decls
    | Cons          hd.uniqueId = @lhs.uniqueId
                    tl.uniqueId = @hd.uniqueId
                    lhs.uniqueId = @tl.uniqueId
                    lhs.decls = @hd.decl : @tl.decls
    | Nil           lhs.uniqueId = @lhs.uniqueId
                    lhs.decls = []

ATTR Decl [ | | decl : Decl ]

SEM Decl
    | Start         lhs.decl = Decl_Start @name @access @encoding @expr.expr
    | Function      lhs.genEnv = singletonGlobal @name (tpScheme2Ts @lhs.syn @lhs.dataKind @ty)
                    expr.uniqueId = @lhs.uniqueId
                    expr.env = @lhs.env --}trace ("entering function : " ++ I.stringFromId @name ++ " : expr : " ++ show @expr.expr ++ " : with module env : " ++ show @lhs.env) @lhs.env
                    loc.uniqueId = @expr.uniqueId
                    loc.lookup = (@loc.uniqueId, @lhs.env) |?| (@name, "Decl")
                    lhs.uniqueId = first @loc.lookup
                    loc.ct = @expr.ct -- TODO: this is just a check ++ [ EqT "Decl" @expr.t (second @loc.lookup) ] ++ third @loc.lookup
                    lhs.ct = @loc.ct --}trace ("function " ++ I.stringFromId @name ++ " : type : " ++ show @expr.t ++ " : constraints : " ++ show @loc.ct) @loc.ct
                    lhs.showIt = [(I.stringFromId @name, (t2tsall $ @lhs.sub -$- @expr.t), @ty)]
                    lhs.decl = Decl_Function @name @access @encoding @expr.expr @customs @ty
    | Abstract      lhs.genEnv = singletonGlobal @name (tpScheme2Ts @lhs.syn @lhs.dataKind @ty)
                    lhs.decl = Decl_Abstract @name @access @arity @customs @ty
    | Constructor   loc.t = tpScheme2Ts @lhs.syn @lhs.dataKind @ty
                    lhs.genCons = unionDataAnns @lhs.data (singletonDataCon @datalink @name (ts2t @loc.t))
                    lhs.genEnv = singletonGlobal @name @loc.t
                    lhs.decl = Decl_Constructor @name @access @arity @tag @customs @datalink @ty
    | Data          lhs.genData = singletonDataAnns @name
                    lhs.genDataKind = Map.singleton @name @typeKind
                    lhs.decl = Decl_Data @name @access @kind @customs @typeKind
    | Synonym       lhs.genSyn = Map.singleton @name @tpSynonym
                    lhs.decl = Decl_Synonym @name @access @kind @customs @tpSynonym
    | Custom        lhs.decl = Decl_Custom @name @access @kind @customs

{
tpScheme2Ts :: Map I.Id Synonym -> Map I.Id Int -> T.TpScheme -> Ts
tpScheme2Ts synonyms dataKind tpScheme = ({-snd $ traceShow "tpScheme2Ts" (tpScheme,-}t2tsall $ preds' $ transformTp dataKind tp')
    where
        synonyms' = transformSynonyms synonyms
        (preds, tp) = transformTpScheme tpScheme
        tp' = expandTypes synonyms' tp
        preds' = transformPreds dataKind preds

transformSynonyms :: Map I.Id Synonym -> Map String (Int, T.Tps -> T.Tp)
transformSynonyms synonym = Map.mapKeys I.stringFromId $ Map.map (\(Synonym a) -> a) $ synonym

transformTpScheme :: T.TpScheme -> (T.Predicates, T.Tp)
transformTpScheme tpScheme =
    let unquantified = T.unquantify tpScheme
        ty = T.unqualify unquantified
        preds = T.qualifiers unquantified
    in  (preds, ty)

expandTypes :: Map String (Int, T.Tps -> T.Tp) -> T.Tp -> T.Tp
expandTypes = Syn.expandType

transformTp :: Map I.Id Int -> T.Tp -> T
transformTp _ (T.TVar i) = TVar i
transformTp dataKind (T.TCon ('D':'i':'c':'t':n)) = do
    let (p,d) = mapFst (head n :) $ span isLower $ tail n
        (defaultKind,typecon) = case d of
            ('L':'i':'s':'t':[]) -> (1,"[]")
            ('T':'u':'p':'l':'e':tuplekind) -> (read tuplekind,case defaultKind of
                0 -> "()"
                1 -> internalError "LVM_Syntax.ag" "transformTp" "Tuple1 doesn't exist"
                _ -> "(" ++ replicate (defaultKind - 1) ',' ++ ")")
            _ -> (0,d)
        kind = M.fromMaybe defaultKind $ Map.lookup (I.idFromString d) dataKind
    {- traceShow ("transformTp | n=" ++ n ++ " | kind=" ++ show kind) $ -}
    (map (\uniqueId -> TPred p (TVar uniqueId)) [0..(kind-1)])
        |=> (TPred p (applyT (TCon typecon) (map (\uniqueId -> TVar uniqueId) [0..(kind-1)])))
transformTp _ (T.TCon s) = TCon s
transformTp dataKind (T.TApp t1 t2) = TAp (transformTp dataKind t1) (transformTp dataKind t2)

transformPreds :: Map I.Id Int ->  T.Predicates -> (T -> T)
transformPreds dataKind preds =
    let transformPred (T.Predicate s t) = TPred s (transformTp dataKind t)
    in  (|=>) $ map transformPred preds
}
---------------
-- Type Expr --
---------------
ATTR Expr Alts Alt Pat [ env : { Env } sub : { Sub } | uniqueId : Int | t : { T } ct USE {++} {[]} : { Constraints } ]
-- Expr
ATTR Expr [ | | expr : Expr]
SEM Expr
    | Let       lhs.expr = Expr_Let @binds.binds @expr.expr (Just $ @lhs.sub -$- @loc.t)
                loc.t = TVar @lhs.uniqueId
                lhs.ct = [ EqT "Let" @loc.t @expr.t ] ++ @binds.ct ++ @expr.ct
                loc.env = unionLocal @binds.extendEnv @lhs.env
                binds.env = @loc.env
                expr.env = @loc.env
                binds.uniqueId = @lhs.uniqueId + 1
                expr.uniqueId = @binds.uniqueId
                lhs.uniqueId = @expr.uniqueId
    | Match     lhs.expr = Expr_Match @name @alts.alts (Just $ @lhs.sub -$- @loc.t)
                loc.t = TVar @lhs.uniqueId
                loc.lookup = (@lhs.uniqueId + 1, @lhs.env) |?| (@name, "Match")
                lhs.ct = [ EqT "Match" @alts.t ((second @loc.lookup) |-> @loc.t) ] ++ third @loc.lookup ++ @alts.ct
                alts.uniqueId = first @loc.lookup
                lhs.uniqueId = @alts.uniqueId
    | Ap        lhs.expr = Expr_Ap @expr1.expr @expr2.expr (Just $ @lhs.sub -$- @loc.t)
                loc.t = TVar @lhs.uniqueId
                lhs.ct = [ EqT "Ap" @expr1.t (@expr2.t |-> @loc.t) ] ++ @expr1.ct ++ @expr2.ct
                expr1.uniqueId = @lhs.uniqueId + 1
                expr2.uniqueId = @expr1.uniqueId
    | Lam       lhs.expr = Expr_Lam @name @expr.expr (Just $ @lhs.sub -$- @loc.t)
                loc.t = TVar @lhs.uniqueId
                loc.nameT = TVar (@lhs.uniqueId + 1)
                loc.ann1 = (AnnVar (@lhs.uniqueId + 2), AnnVar (@lhs.uniqueId + 3))
                loc.ann2 = AnnVar (@lhs.uniqueId + 4)
                lhs.ct = [ EqT "Lam" @loc.t (@loc.nameT |-> @expr.t)] ++ @expr.ct
                expr.env = insertLocal @name (t2ts @loc.nameT) @lhs.env
                expr.uniqueId = @lhs.uniqueId + 5
                lhs.uniqueId = @expr.uniqueId
    | ConId     lhs.expr = Expr_ConId @name (Just $ @lhs.sub -$- @loc.t)
                loc.t = TVar @lhs.uniqueId
                loc.lookup = (@lhs.uniqueId + 1, @lhs.env) |?| (@name, "ConId")
                lhs.ct = [ EqT "ConId" @loc.t (second @loc.lookup) ] ++ third @loc.lookup
                lhs.uniqueId = first @loc.lookup
    | ConTag    lhs.expr = Expr_ConTag @expr.expr @arity (Just $ @lhs.sub -$- @loc.t)
                loc.t = TVar @lhs.uniqueId
                lhs.ct = [ EqT "ConTag" @loc.t (arity2T (@lhs.uniqueId + 1) @arity) ] ++ @expr.ct
                expr.uniqueId = @lhs.uniqueId + @arity + 2
                lhs.uniqueId = @expr.uniqueId
    | Var       lhs.expr = Expr_Var @name (Just $ @lhs.sub -$- @loc.t)
                loc.t = TVar @lhs.uniqueId
                loc.lookup = (@lhs.uniqueId + 1, @lhs.env) |?| (@name, "Var")
                lhs.ct = [ EqT "Var" @loc.t (second @loc.lookup) ] ++ third @loc.lookup
                lhs.uniqueId = first @loc.lookup
    | Lit       lhs.expr = Expr_Lit @lit.lit (Just $ @lhs.sub -$- @loc.t)
                loc.t = TVar @lhs.uniqueId
                loc.ann = AnnVar (@lhs.uniqueId + 1)
                lhs.ct = [ EqT "Lit" @loc.t @lit.t ]
                lhs.uniqueId = @lhs.uniqueId + 2

-- Let bindings
ATTR Binds Binds' Bind
    [ env : { Env }
      sub : { Sub }
    | uniqueId : Int
    | extendEnv USE {Map.union} {Map.empty} : {Map I.Id Ts}
      ct USE {++} {[]} : { Constraints }
    ]
ATTR Binds [ | | binds : Binds ]
SEM Binds
    | Rec       lhs.binds = Binds_Rec @binds.binds
                lhs.ct = @binds.ct
                lhs.extendEnv = @binds.extendEnv
                binds.uniqueIdEnv = @lhs.uniqueId
                binds.uniqueId = @binds.uniqueIdEnv
                lhs.uniqueId = @binds.uniqueId
    | Strict    lhs.binds = Binds_Strict @bind.bind
                lhs.ct = @bind.ct
                lhs.extendEnv = @bind.extendEnv
                bind.uniqueIdEnv = @lhs.uniqueId
                bind.uniqueId = @bind.uniqueIdEnv
                lhs.uniqueId = @bind.uniqueId
    | NonRec    lhs.binds = Binds_NonRec @bind.bind
                lhs.ct = @bind.ct
                lhs.extendEnv = @bind.extendEnv
                bind.uniqueIdEnv = @lhs.uniqueId
                bind.uniqueId = @bind.uniqueIdEnv
                lhs.uniqueId = @bind.uniqueId

ATTR Binds' [ | uniqueIdEnv : Int | binds : Binds' ]
SEM Binds'
    | Cons      lhs.binds = @hd.bind : @tl.binds
                lhs.ct = @hd.ct ++ @tl.ct
                lhs.extendEnv = Map.union @hd.extendEnv @tl.extendEnv
                hd.uniqueId = @lhs.uniqueId
                tl.uniqueId = @hd.uniqueId
                lhs.uniqueId = @tl.uniqueId
                hd.uniqueIdEnv = @lhs.uniqueIdEnv
                tl.uniqueIdEnv = @hd.uniqueIdEnv
                lhs.uniqueIdEnv = @tl.uniqueIdEnv
    | Nil       lhs.binds = []

ATTR Bind [ | uniqueIdEnv : Int | bind : Bind ]
SEM Bind
    | Bind      lhs.bind = Bind_Bind @name @expr.expr (Just $ @lhs.sub -$- @loc.t)
                loc.t = (TsVar @lhs.uniqueIdEnv)
                lhs.ct = [ EqGen "Bind" @loc.t (@expr.t,@expr.ct,@lhs.env) ]
                expr.uniqueId = @lhs.uniqueId
                lhs.uniqueId = @expr.uniqueId
                -- expr uses uniqueId and env.
                -- env depends on extendEnv.
                -- extendEnv depends on all bind in a let binding having a uniqueId
                -- *Cyclic* -> solved with uniqueIdEnv
                lhs.extendEnv = Map.singleton @name @loc.t
                lhs.uniqueIdEnv = @lhs.uniqueIdEnv + 1

-- Guard alternatives

ATTR Alts [ | | alts : Alts ]
SEM Alts
    | Cons      lhs.alts = @hd.alt : @tl.alts
                loc.t = @tl.t
                lhs.ct = [ EqT "Alts Cons" @tl.t @hd.t ] ++ @hd.ct ++ @tl.ct
                hd.uniqueId = @lhs.uniqueId
                tl.uniqueId = @hd.uniqueId
                lhs.uniqueId = @tl.uniqueId
    | Nil       lhs.alts = []
                loc.t = TVar @lhs.uniqueId
                lhs.uniqueId = @lhs.uniqueId + 1

ATTR Alt [ | | alt : Alt ]
SEM Alt
    | Alt       lhs.alt = Alt_Alt @pat.pat @expr.expr
                loc.t = TVar @lhs.uniqueId
                lhs.ct = [ EqT "Alt" @loc.t (@pat.t |-> @expr.t) ] ++ @pat.ct ++ @expr.ct
                expr.env = unionLocal @pat.extendEnv @lhs.env
                pat.uniqueId = @lhs.uniqueId + 1
                expr.uniqueId = @pat.uniqueId
                lhs.uniqueId = @expr.uniqueId

ATTR Pat [ | | extendEnv USE {Map.union} {Map.empty} : {Map I.Id Ts} pat : Pat ]
SEM Pat
    | ConId     lhs.pat = Pat_ConId @name @ids
                loc.t = TVar @lhs.uniqueId
                loc.lookup = (@lhs.uniqueId + 1, @lhs.env) |?| (@name, "Pat")
                loc.idXidsWt = assignT (first @loc.lookup) @ids
                lhs.ct = (eqAll "Pat ConId" (@loc.t:(map snd $ snd $ @loc.idXidsWt)) (let (xs,x) = splitCons $ second @loc.lookup in x:xs)) ++ third @loc.lookup
                lhs.uniqueId = fst @loc.idXidsWt
                lhs.extendEnv = Map.fromList $ map (\(id_,type_) -> (id_, t2ts type_)) $ snd $ @loc.idXidsWt
    | ConTag    lhs.pat = Pat_ConTag @tag @arity @ids
                loc.t = TVar @lhs.uniqueId
                loc.idXidsWt = assignT (@lhs.uniqueId + @arity + 2) @ids
                lhs.ct = eqAll "Pat ConTag" (@loc.t:(map snd $ snd $ @loc.idXidsWt)) (let (xs,_) = splitCons $ (arity2T (@lhs.uniqueId + 1) @arity) in tuple @arity xs:xs)
                lhs.uniqueId = fst @loc.idXidsWt
                lhs.extendEnv = Map.fromList $ map (\(id_,type_) -> (id_, t2ts type_)) $ snd $ @loc.idXidsWt
    | Lit       lhs.pat = Pat_Lit @lit.lit
                loc.t = TVar @lhs.uniqueId
                lhs.ct = [ EqT "Pat Lit" @loc.t @lit.t ]
                lhs.uniqueId = @lhs.uniqueId + 1
    | Default   lhs.pat = Pat_Default
                lhs.t = TVar @lhs.uniqueId
                lhs.uniqueId = @lhs.uniqueId + 1

-- Typed literals
ATTR Literal [ | | t : { T } lit : Literal ]
SEM Literal
    | LitInt    lhs.lit = Literal_LitInt @int_
                loc.t = TCon "Int"
    | LitDouble lhs.lit = Literal_LitDouble @double_
                loc.t = TCon "Double"
    | LitBytes  lhs.lit = Literal_LitBytes @bytes_
                loc.t = TCon "Bytes"

{
-- Debug
printDeclKindCustoms :: Int -> Module.DeclKind -> [Module.Custom] -> String
printDeclKindCustoms level declKind customs = (concat $ replicate level "    ") ++ (show declKind) ++ "\n" ++ (printCustoms (level + 1) customs)

printCustoms :: Int -> [Module.Custom] -> String
printCustoms _ [] = []
printCustoms level (custom:customs) = (concat $ replicate level "    ") ++ (case custom of
    Module.CustomInt x -> "CustomInt " ++ show x
    Module.CustomBytes b -> "CustomBytes " ++ (show b) ++ " | " ++ (B.stringFromBytes b)
    Module.CustomName i -> "CustomName " ++ show i
    Module.CustomLink i declkind -> "CustomLink " ++ show i ++ " : " ++ show declkind
    Module.CustomDecl declkind customs2 -> "CustomDecl " ++ show declkind ++ " :(\n" ++ printCustoms (level + 1) customs2 ++ ")"
    Module.CustomNothing -> "CustomNothing") ++ "\n" ++ printCustoms level customs

-- Wrap synonym
newtype Synonym = Synonym (Int, T.Tps -> T.Tp)
instance Show Synonym where
    show (Synonym (i, _)) = "Synonym (" ++ (show i) ++ ", Tps -> Tp )"

-- to OptimizeModule
coreModule2OptimizeModule :: Expr.CoreModule -> OptimizeModule
coreModule2OptimizeModule (Module.Module name majorV minorV decls) =
    OptimizeModule_Module name majorV minorV (coreDecls2Decls decls)

coreDecls2Decls :: [Expr.CoreDecl] -> Decls
coreDecls2Decls = map coreDecl2Decl

coreDecl2Decl :: Expr.CoreDecl -> Decl
coreDecl2Decl (Module.DeclValue name access encoding expr []) =
    Decl_Start name access encoding (coreExpr2Expr expr)
coreDecl2Decl (Module.DeclValue name access encoding expr customs) =
    Decl_Function name access encoding (coreExpr2Expr expr) customs
    --(tracePretty ("Function: " ++ (show name) ++ " => ") customs)
    (customsToTpScheme name customs)
coreDecl2Decl (Module.DeclAbstract name access arity customs) =
    Decl_Abstract name access arity customs
    --(tracePretty ("Abstract: " ++ (show name) ++ " => ") customs)
    (customsToTpScheme name customs)
coreDecl2Decl (Module.DeclCon name access arity tag customs) =
    Decl_Constructor name access arity tag customs
    --(trace (trace ("Custom: " ++ (show name) ++ " => ") (printCustoms 1 customs)) customs)
    --(tracePretty ("Constructor: " ++ (show name) ++ " => ") customs)
    (customsToLink name customs)
    (customsToTpScheme name customs)
coreDecl2Decl (Module.DeclCustom name access kind customs) =
    --(trace (trace ("Custom: " ++ (show name) ++ " => ") (printDeclKindCustoms 1 kind customs)) customs)
    case kind of
        Module.DeclKindCustom ident
            | show ident == "\"data\"" -> Decl_Data name access kind customs (C.arityFromCustoms (show name) customs)
            | show ident == "\"typedecl\"" -> Decl_Synonym name access kind ({-trace (trace ("Custom: " ++ (show name) ++ " => ") (printDeclKindCustoms 1 kind customs))-} customs) (Synonym $ C.typeSynFromCustoms (show name) customs)
        _ -> Decl_Custom name access kind customs
coreDecl2Decl _ = internalError "LVM_Syntax.ag" "coreDecl2Decl" "unsupported decl"

customsToTpScheme :: I.Id -> [Module.Custom] -> T.TpScheme
customsToTpScheme name xs = C.typeFromCustoms (show name) xs

customsToLink :: I.Id -> [Module.Custom] -> I.Id
customsToLink con [] = internalError "LVM_Syntax.ag" "customsToLink" ("no link for : " ++ show con)
customsToLink con ((Module.CustomLink name declkind):_)
    | show declkind == "DeclKindCustom \"data\"" = name
    | True = internalError "LVM_Syntax.ag" "customsToLink" ("different link for : " ++ show con ++ " : " ++ show declkind)
customsToLink con (_:cs) = customsToLink con cs

coreExpr2Expr :: Expr.Expr -> Expr
coreExpr2Expr (Expr.Let binds expr) =
    Expr_Let (coreBinds2Binds binds) (coreExpr2Expr expr) Nothing
coreExpr2Expr (Expr.Match name alts) =
    Expr_Match name (coreAlts2Alts alts) Nothing
coreExpr2Expr (Expr.Ap expr1 expr2) =
    Expr_Ap (coreExpr2Expr expr1) (coreExpr2Expr expr2) Nothing
coreExpr2Expr (Expr.Lam name expr) =
    Expr_Lam name (coreExpr2Expr expr) Nothing
coreExpr2Expr (Expr.Con (Expr.ConId name)) =
    Expr_ConId name Nothing
coreExpr2Expr (Expr.Con (Expr.ConTag tag arity)) =
    Expr_ConTag (coreExpr2Expr tag) arity Nothing
coreExpr2Expr (Expr.Var name) =
    Expr_Var name Nothing
coreExpr2Expr (Expr.Lit lit) =
    Expr_Lit (coreLit2Lit lit) Nothing

coreBinds2Binds :: Expr.Binds -> Binds
coreBinds2Binds (Expr.Rec binds) =
    Binds_Rec (map coreBind2Bind binds)
coreBinds2Binds (Expr.NonRec bind) =
    Binds_NonRec (coreBind2Bind bind)
coreBinds2Binds (Expr.Strict bind) =
    Binds_Strict (coreBind2Bind bind)

coreBind2Bind :: Expr.Bind -> Bind
coreBind2Bind (Expr.Bind name expr) =
    Bind_Bind name (coreExpr2Expr expr) Nothing

coreAlts2Alts :: Expr.Alts -> Alts
coreAlts2Alts = map coreAlt2Alt

coreAlt2Alt :: Expr.Alt -> Alt
coreAlt2Alt (Expr.Alt pat expr) =
    Alt_Alt (corePat2Pat pat) (coreExpr2Expr expr)

corePat2Pat :: Expr.Pat -> Pat
corePat2Pat (Expr.PatCon (Expr.ConId name) ids) =
    Pat_ConId name ids
corePat2Pat (Expr.PatCon (Expr.ConTag tag arity) ids) =
    Pat_ConTag tag arity ids
corePat2Pat (Expr.PatLit lit) =
    Pat_Lit (coreLit2Lit lit)
corePat2Pat (Expr.PatDefault) =
    Pat_Default

coreLit2Lit :: Expr.Literal -> Literal
coreLit2Lit (Expr.LitInt int) =
    Literal_LitInt int
coreLit2Lit (Expr.LitDouble double) =
    Literal_LitDouble double
coreLit2Lit (Expr.LitBytes bytes) =
    Literal_LitBytes bytes

-- uuagc wrapping
wrap_module :: OptimizeModule -> Syn_OptimizeModule
wrap_module module_ = wrap_OptimizeModule (sem_OptimizeModule module_) Inh_OptimizeModule { }
constraints :: Syn_OptimizeModule -> Constraints
constraints = ct_Syn_OptimizeModule
showIt :: Syn_OptimizeModule -> [(String, Ts, T.TpScheme)]
showIt = showIt_Syn_OptimizeModule
optimizeModule :: Syn_OptimizeModule -> OptimizeModule
optimizeModule = optimizeModule_Syn_OptimizeModule

-- to CoreModule
optimizeModule2CoreModule :: OptimizeModule -> Expr.CoreModule
optimizeModule2CoreModule (OptimizeModule_Module name majorV minorV decls) =
    Module.Module name majorV minorV (decls2CoreDecls decls)

decls2CoreDecls :: Decls -> [Expr.CoreDecl]
decls2CoreDecls = map decl2CoreDecl

decl2CoreDecl :: Decl -> Expr.CoreDecl
decl2CoreDecl (Decl_Start name access encoding expr) =
    Module.DeclValue name access encoding (expr2CoreExpr expr) []
decl2CoreDecl (Decl_Function name access encoding expr customs _) =
    Module.DeclValue name access encoding (expr2CoreExpr expr) customs
    --(trace (show mayTpScheme) customs)
decl2CoreDecl (Decl_Abstract name access arity customs _) =
    Module.DeclAbstract name access arity customs
    --(trace (show tpScheme) customs)
decl2CoreDecl (Decl_Constructor name access arity tag customs _ _) =
    Module.DeclCon name access arity tag customs
    --(trace (show tpScheme) customs)
decl2CoreDecl (Decl_Data name access kind customs _) =
    Module.DeclCustom name access kind customs
decl2CoreDecl (Decl_Synonym name access kind customs _) =
    Module.DeclCustom name access kind customs
decl2CoreDecl (Decl_Custom name access kind customs) =
    Module.DeclCustom name access kind customs

expr2CoreExpr :: Expr -> Expr.Expr
expr2CoreExpr (Expr_Let binds expr _) =
    Expr.Let (binds2CoreBinds binds) (expr2CoreExpr expr)
expr2CoreExpr (Expr_Match name alts _) =
    Expr.Match name (alts2CoreAlts alts)
expr2CoreExpr (Expr_Ap expr1 expr2 _) =
    Expr.Ap (expr2CoreExpr expr1) (expr2CoreExpr expr2)
expr2CoreExpr (Expr_Lam name expr _) =
    Expr.Lam name (expr2CoreExpr expr)
expr2CoreExpr (Expr_ConId name _) =
    Expr.Con (Expr.ConId name)
expr2CoreExpr (Expr_ConTag tag arity _) =
    Expr.Con (Expr.ConTag (expr2CoreExpr tag) arity)
expr2CoreExpr (Expr_Var name _) =
    Expr.Var name
expr2CoreExpr (Expr_Lit lit _) =
    Expr.Lit (lit2CoreLit lit)

binds2CoreBinds :: Binds -> Expr.Binds
binds2CoreBinds (Binds_Rec binds) =
    Expr.Rec (map bind2CoreBind binds)
binds2CoreBinds (Binds_NonRec bind) =
    Expr.NonRec (bind2CoreBind bind)
binds2CoreBinds (Binds_Strict bind) =
    Expr.Strict (bind2CoreBind bind)

bind2CoreBind :: Bind -> Expr.Bind
bind2CoreBind (Bind_Bind name expr _) =
    Expr.Bind name (expr2CoreExpr expr)

alts2CoreAlts :: Alts -> Expr.Alts
alts2CoreAlts = map alt2CoreAlt

alt2CoreAlt :: Alt -> Expr.Alt
alt2CoreAlt (Alt_Alt pat expr) =
    Expr.Alt (pat2CorePat pat) (expr2CoreExpr expr)

pat2CorePat :: Pat -> Expr.Pat
pat2CorePat (Pat_ConId name ids) =
    Expr.PatCon (Expr.ConId name) ids
pat2CorePat (Pat_ConTag tag arity ids) =
    Expr.PatCon (Expr.ConTag tag arity) ids
pat2CorePat (Pat_Lit lit) =
    Expr.PatLit (lit2CoreLit lit)
pat2CorePat Pat_Default =
    Expr.PatDefault

lit2CoreLit :: Literal -> Expr.Literal
lit2CoreLit (Literal_LitInt int) =
    Expr.LitInt int
lit2CoreLit (Literal_LitDouble double) =
    Expr.LitDouble double
lit2CoreLit (Literal_LitBytes bytes) =
    Expr.LitBytes bytes
}
