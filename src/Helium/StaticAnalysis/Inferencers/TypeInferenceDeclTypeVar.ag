-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
-- 
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Assigns type variables, which are used for both the type inference and the
-- code generation. This allows to recover the type information from the output
-- of the constraint solver.
--
-------------------------------------------------------------------------------

ATTR Body
  [ | betaDeclUnique : Int | ]

SEM Module
  | Module
    body.betaDeclUnique = 1000000000 -- 2 ^ 30

ATTR Declaration Declarations MaybeDeclarations
  Expression Expressions MaybeExpression
  Statements Statement Qualifiers Qualifier Alternatives Alternative
  GuardedExpressions GuardedExpression RecordExpressionBindings
  RecordExpressionBinding RecordPatternBindings RecordPatternBinding
  FunctionBindings FunctionBinding LeftHandSide RightHandSide
  Patterns Pattern [ | betaDeclUnique:Int | ]

SEM Declaration
  | FunctionBindings
    -- One type variable for the function type
    bindings.betaDeclUnique = @lhs.betaDeclUnique + 1
  | PatternBinding
    pattern.betaDeclUnique = @lhs.betaDeclUnique + 1
  | Instance
    where   . betaDeclUnique            = @lhs.betaDeclUnique + 1 + length(@typeVariables)
    loc     . instBeta              = TVar @lhs.betaDeclUnique
    loc     . typeVariables        = namesInType (chead $ @types.self)
    loc     . instanceBetas         = (zip @typeVariables [TVar n | n <- [@lhs.betaDeclUnique + 1..]])
    loc     . instsType             = makeTpFromType @instanceBetas (chead $ @types.self)
    loc     . instanceTpScheme      = addPredicatesToTpScheme (@superClasses) $ makeTpSchemeFromType (chead @types.self)
    loc     . superClasses          = getSuperClasses @context.self

{
getSuperClasses ::  ContextItems -> [(String, Name)]
getSuperClasses = map (\(ContextItem_ContextItem _ n vs) -> (getNameName n, var vs))
    where
        var [vs] = name $ namesInType vs
        var _ = error "Type variable not a single type"
        name [n] = n
        name _ = error "Type variable not a single name"

addPredicatesToTpScheme :: [(String, Name)] -> TpScheme -> TpScheme
addPredicatesToTpScheme preds (Quantification (nrs, map, q)) =
    Quantification (nrs, map, foldr addPredicate q preds)
    where
        addPredicate :: (String, Name) -> QType -> QType
        addPredicate (className, var) qtype = let
            (preds, tp) = split qtype
            pred = Predicate className (maybe (error "Undefined type variable") (TVar . fst) $ find (\n -> snd n == getNameName var) map)
            in (pred : preds) .=>. tp
}
SEM Expression
  | Lambda
    -- One type variable for the function type
    patterns.betaDeclUnique = @lhs.betaDeclUnique + 1
  | Case
    -- One type variable for the scrutinee, one type for the right hand side
    expression.betaDeclUnique = @lhs.betaDeclUnique + 2
  | InfixApplication
    leftExpression.betaDeclUnique = @lhs.betaDeclUnique + 1
  | Comprehension
    -- One type variable for the elements of the list
    expression.betaDeclUnique = @lhs.betaDeclUnique + 1
  | Do
    -- One type variable for the monad type (kind * -> *)
    statements.betaDeclUnique = @lhs.betaDeclUnique + 1
  | Variable
    lhs.betaDeclUnique = @lhs.betaDeclUnique + 1
  | Constructor
    lhs.betaDeclUnique = @lhs.betaDeclUnique + 1
  | List
    -- One type variable for the elements of the list
    expressions.betaDeclUnique = @lhs.betaDeclUnique + 1
  | Enum
    -- One type variable for the elements of the list
    from.betaDeclUnique = @lhs.betaDeclUnique + 1
  | Tuple
    expressions.betaDeclUnique = @lhs.betaDeclUnique + 1

SEM Statement
  | Expression
    -- One type variable for the value in the monad (eg the 'a' in 'IO a')
    expression.betaDeclUnique = @lhs.betaDeclUnique + 1

ATTR Pattern          [ | | beta:Tp ]

SEM Pattern
  | Hole
    lhs.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | Literal
    lhs.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | Variable
    lhs.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | Constructor
    patterns.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | InfixConstructor
    leftPattern.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | List
    patterns.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | Tuple
    patterns.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | Record
    recordPatternBindings.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | Negate
    lhs.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | As
    pattern.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | Wildcard
    lhs.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | Irrefutable
    pattern.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | NegateFloat
    lhs.betaDeclUnique = @lhs.betaDeclUnique + 1
    loc.beta = TVar @lhs.betaDeclUnique

  | Successor
    loc.beta = internalError "TypeInferenceDeclTypeVar.ag" "n/a" "Pattern.Successor"

{
chead [x] = x
chead x = error "Not a singleton"
}
