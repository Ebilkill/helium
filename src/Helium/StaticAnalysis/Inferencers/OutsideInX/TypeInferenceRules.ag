
ATTR Module Body Declaration Declarations Expression Expressions
     GuardedExpression GuardedExpressions
     MaybeExpression RecordExpressionBinding
     RightHandSide Alternative Alternatives FunctionBinding
     FunctionBindings RecordExpressionBindings
     AnnotatedType Types Constructor AnnotatedTypes 
     ContextItem FieldDeclaration Constructors ContextItems 
     FieldDeclarations Type Literal LeftHandSide RightHandSide
     Pattern Patterns
        [ 
                typeSignatures : {M.Map Name (TyVar, PolyType)}
                substitution : {[(TyVar, MonoType)]}
                importEnvironment : ImportEnvironment
                axioms : {[Axiom]}
                typeSignatureConstraints : {[Constraint]}
                typeVariableReplace : {[(String, MonoType)]}
                className : {Maybe Name}

            |   betaUnique : Integer
            |   assumptions USE {M.unionWith (++)} {M.empty} : {M.Map Name [(Name, TyVar)]}
                environment USE {M.union} {M.empty} : {M.Map Name TyVar}
                constraints USE {(++)} {[]} : {[Constraint]}
                givenConstraints USE {(++)} {[]} : {[Constraint]}
                bindingGroups USE {(++)} {[]} : {[BindingGroup]}
                touchables USE {(++)} {[]} : {[TyVar]}
                toplevelTypes USE {M.union} {M.empty}  : TypeEnvironment
                typeSignaturesCollect USE {M.union} {M.empty} : {M.Map Name (TyVar, PolyType)}
                typeErrors USE {(++)} {[]} : TypeErrors

                tlEnvironment USE {M.union} {M.empty} : {M.Map Name TyVar}
                resolvedContraints USE {(++)} {[]} : {[Constraint]}
                gadtConstraints USE {(++)} {[]} : GADTConstraints
                gadtUsed USE {(||)} {False} : Bool
        ]

ATTR MaybeDeclarations Qualifier Qualifiers Statement Statements
        [ 
                typeSignatures : {M.Map Name (TyVar, PolyType)}
                substitution : {[(TyVar, MonoType)]}
                importEnvironment : ImportEnvironment
                axioms : {[Axiom]}
                typeSignatureConstraints : {[Constraint]}
                typeVariableReplace : {[(String, MonoType)]}
                className : {Maybe Name}
            |   betaUnique : Integer
            |   environment USE {M.union} {M.empty} : {M.Map Name TyVar}
                bindingGroups USE {(++)} {[]} : {[BindingGroup]}
                typeSignaturesCollect USE {M.union} {M.empty} : {M.Map Name (TyVar, PolyType)}
                typeErrors USE {(++)} {[]} : TypeErrors
                resolvedContraints USE {(++)} {[]} : {[Constraint]}
        ]

ATTR Body [  | |               substitutionCollect : {[(TyVar, MonoType)]}]

{

unifyVar :: TyVar -> TyVar -> Constraint
unifyVar v1 v2 = Constraint_Unify (var v1) (var v2)

substitutePoly :: TyVar -> [(TyVar, MonoType)] -> MonoType
substitutePoly v env = case lookup v env of
    Nothing -> error $ "Cannot provide substitution for " ++ show v
    Just m -> m

bindTypeVariables :: [TyVar] -> PolyType -> PolyType
bindTypeVariables = flip (foldr ((PolyType_Bind .) . UL.bind))

type SolveResult = ([TypeError], [Warning], [(TyVar, MonoType)], Constraints)

constructErrors :: (Either NamedSolverError Solution, Graph) -> SolveResult
constructErrors (et, _) = either (\e -> (createTypeError e, [], [], [])) (\solution -> ([], [], substitution solution, residual solution)) et

getTypeErrors :: SolveResult -> [TypeError]
getTypeErrors (te, _, _, _) = te

getWarnings :: SolveResult -> [Warning]
getWarnings (_, wa, _, _) = wa

getSubstitution :: SolveResult -> [(TyVar, MonoType)]
getSubstitution (_, _, subs, _) = subs

getResidualConstraints :: SolveResult -> [Constraint]
getResidualConstraints (_, _, _, cs) = cs

lookupType :: M.Map Name (TyVar, PolyType) -> Name -> TyVar -> TpScheme
lookupType env name _ = 
    case M.lookup name env of
        Nothing -> internalError "TypeInferenceRules" "lookupType" "Top level type not found"
        Just (_, p) -> polyTypeToTypeScheme p
}

SEM Module
    | Module
        lhs . dictionaryEnvironment = emptyDictionaryEnvironment
        lhs . toplevelTypes = const id (trace "Residual constraints" $ traceShow (getResidualConstraints @solveResults)) $ if null @typeErrors then M.mapWithKey (lookupType @body.typeSignaturesCollect) @body.tlEnvironment else M.empty -- 
        loc . typeErrors = const id (trace (unlines $ map show $ sortOn fst $ nub $ @substitution)) $ concatMap (makeTypeError @tyvars) (getResidualConstraints @solveResults \\ @body.resolvedContraints) ++ getTypeErrors @solveResults ++ @body.typeErrors
        lhs . warnings = getWarnings @solveResults
        loc . axioms = typeSynonymsToAxioms (typeSynonyms @lhs.importEnvironment) ++ classEnvironmentToAxioms (importEnvironmentToTypeFamilies @lhs.importEnvironment) (classEnvironment @lhs.importEnvironment)
        body . axioms = @axioms
        body . betaUnique = 1
        loc . substitution = (if null @body.assumptions then id else trace "Unresolved assumptions" . traceShow @body.assumptions) (getSubstitution @solveResults ++ @body.substitutionCollect)
        body . substitution = @substitution
        loc . constrs = @body.constraints
        loc . tyvars = @body.touchables
        loc . solveResults = constructErrors $ contFreshM (solve @axioms (map (uncurry (Constraint_Unify . var)) @body.substitutionCollect) (@constrs) @tyvars) @body.betaUnique 
        body . typeSignatures = M.map (\tps -> (integer2Name (-1), tpSchemeToPolyType (importEnvironmentToTypeFamilies @lhs.importEnvironment) tps)) $ typeEnvironment @lhs.importEnvironment
        body . instanceType = Nothing
        body . className = Nothing
        body . typeSignatureConstraints = []

SEM Body
    | Body
        declarations . bindingGroups    = []
        lhs . constraints = @loc.constraints
        -- lhs . toplevelTypes = M.map (monoTypeToTypeScheme.getMonoFromPoly.snd) @lhs.typeSignatures `M.union` M.map (monoTypeToTypeScheme.getMonoFromPoly.snd) @typeSignatures
        declarations . betaUnique = @lhs.betaUnique
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            loc . constraints,
            lhs . betaUnique,
            lhs . substitutionCollect,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let !inputBDG = (True, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables, Nothing, @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups

ATTR FunctionBinding FunctionBindings [ betasLeft : {[TyVar]} betaRight : TyVar | | name : Name numberOfPatterns : Integer  ]


SEM Declaration
    | FunctionBindings
        lhs . betaUnique        = @bindings.betaUnique
        lhs . bindingGroups     = [@bindingGroup]
        loc . bindingGroup      = (@environment, @assumptions, @constraints, @lhs.typeSignatureConstraints ++ @instanceCons ++ @bindings.givenConstraints, @bindings.gadtConstraints)
        -- lhs . toplevelTypes  = M.singleton (@bindings.name) (maybe @err polyTypeToTypeScheme $ lookup @beta @lhs.substitution)
        lhs . tlEnvironment     = @environment
        loc . environment       = if isJust @lhs.className then M.empty else M.singleton @bindings.name @beta 
        loc . assumptions       = @bindings.assumptions 
        lhs . touchables        = @beta : @br : @bls ++ @bindings.touchables
        loc . constraints       = @instanceCons ++ @parameterCons ++ @bindings.constraints 
        loc . bls               = take (fromInteger @bindings.numberOfPatterns) (map integer2Name [(@lhs.betaUnique + 2)..])
        loc . br                = integer2Name $ @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . parameterCons     = [Constraint_Unify (var @beta) (foldr ((:-->:) . var) (var @br) @bls)]
        loc . (instanceType, bu) = case @lhs.className of
                                        Nothing -> (Nothing, (@lhs.betaUnique + 2 + @bindings.numberOfPatterns))
                                        Just cn -> let 
                                                (classTypeVariables, classFunctions) = fromMaybe (internalError "TypeInferenceRules" "n/a" "class not found") $
                                                    M.lookup cn (classMemberEnvironment @lhs.importEnvironment)
                                                (_, functionTpScheme, _, _) = fromMaybe (internalError "TypeInferenceRules" "n/a" "class function not found")
                                                    (find (\(n, _, _, _) -> n == @bindings.name) classFunctions) 
                                                (polyType, mapping) = tpSchemeToPolyType' (importEnvironmentToTypeFamilies @lhs.importEnvironment) (map show classTypeVariables) functionTpScheme
                                            
                                                (fMapping, (freshend, bu)) = freshenWithMapping [] (@lhs.betaUnique + 2 + @bindings.numberOfPatterns) polyType
                                                replacedFreshened = UL.substs (combineSubsitutions @lhs.typeVariableReplace mapping fMapping) freshend
                                            in (Just replacedFreshened, bu)
        loc . instanceCons      = maybe [] (\it -> [Constraint_Inst (var @beta) (foldr addConstraint it @lhs.typeSignatureConstraints)])  @instanceType    
        loc . err               = internalError "TypeInferenceRules.ag" "FunctionBindings" ("No substitution found for " ++ show @bindings.name)
        bindings . betasLeft    = @bls 
        bindings . betaRight    = @br 
        bindings . betaUnique   = @bu
        bindings . className    = Nothing
    | PatternBinding
        lhs . tlEnvironment     = @environment
        lhs . bindingGroups     = [@bindingGroup]
        loc . bindingGroup      = (@environment, @assumptions, @constraints, [], @righthandside.gadtConstraints)
        --lhs . toplevelTypes   = M.fromList $ map (\(n, v) -> (n, monoTypeToTypeScheme $ substitutePoly v @lhs.substitution)) $ M.toList @pattern.environment
        lhs . touchables        = @betaRight : @pattern.touchables ++ @righthandside.touchables
        loc . constraints       = [unifyVar @pattern.beta @betaRight, unifyVar @betaRight @righthandside.beta] ++ @pattern.constraints ++ @righthandside.constraints
        loc . environment       = @pattern.environment
        loc . assumptions       = @righthandside.assumptions
        pattern . betaUnique    = @lhs.betaUnique + 1 
        pattern . className     = Nothing
        righthandside . className = Nothing
        loc . betaRight         = integer2Name @lhs.betaUnique
        loc . err               = internalError "TypeInferenceRules.ag" "PatternBinding" "No substitution found for type"

    | TypeSignature
        lhs . touchables        = @beta : map fst (M.elems @ts)
        loc . beta              = integer2Name @lhs.betaUnique
        lhs . betaUnique        = @bu
        lhs . typeSignaturesCollect = @ts
        loc . (ts, bu)          = foldr (\n (m, b) -> let 
                                                (t, b', mapping) = typeToPolytype (importEnvironmentToTypeFamilies @lhs.importEnvironment) b @type.self
                                                t' = t -- replaceTypeVariables mapping @lhs.typeVariableReplace t 
                                                m' = M.insert n (integer2Name b', expandClassPredicates (classEnvironment @lhs.importEnvironment) t') m
                                            in (m', b' + 2)) (M.empty, @lhs.betaUnique + 1) $ @names.self
    | Class
        where       . betaUnique    = @lhs.betaUnique + toInteger (length @simpletype.typevariables)
        loc         . classBetas    = zip (map show @simpletype.typevariables) (map integer2Name [@lhs.betaUnique..])
        lhs         . touchables    = map snd @classBetas ++ @where.touchables
        lhs         . typeSignaturesCollect = @where.typeSignaturesCollect
        where . typeVariableReplace = map (second var) @classBetas
        where . className           = Just  @simpletype.name
        where . typeSignatureConstraints = [Constraint_Class (show @simpletype.name) $ map (var.snd) @classBetas] ++ map (\(ContextItem_ContextItem _ cn ts) -> Constraint_Class (show cn) (map (var . snd) @classBetas)) @context.self
    | Instance
        lhs . touchables = getTypeVariablesFromMonoType @tp ++ take (length @typeVariables) [x | i <- [@lhs.betaUnique..], let x = integer2Name i] ++ @where.touchables
        loc . instanceBetas = (@classBeta, @tp) : [] -- zip (map snd @typeVariables) (map (var . integer2Name) [@lhs.betaUnique..])
        loc . instanceType  = makeTpSchemeFromType $ head @types.self
        loc . typeVariables = getQuantorMap @instanceType
        loc . classBeta     = case (M.lookup @name.self (classMemberEnvironment @lhs.importEnvironment)) of
                                Nothing -> internalError "TypeInferenceRules" "n/a" "Class not found"
                                Just (classBeta, _) -> show $ head classBeta
        loc . ((tp, mapping), bu) = freshen (@lhs.betaUnique + toInteger (length @instanceBetas + 1)) $ (\(_, mapping, x) -> (x, mapping)) $ typeToMonoType (importEnvironmentToTypeFamilies @lhs.importEnvironment) (head @types.self)
        where . betaUnique = @bu
        where . className = Just @name.self
        where . typeSignatureConstraints = 
                    concatMap (
                        \(ContextItem_ContextItem _ cn ts) -> expandClassPredicate (classEnvironment @lhs.importEnvironment) $ Constraint_Class (show cn) 
                            [maybe (error "Unknown type variable") var $ lookup (show (makeTpSchemeFromType $ head ts)) @mapping]
                    ) @context.self
        where . typeVariableReplace = reverse $ @instanceBetas


{
contextToAxiom :: [(String, TyVar)] -> ContextItem -> [Axiom]
contextToAxiom classBetas (ContextItem_ContextItem r n types) = let err = internalError "TypeInferenceRules" "n/a" "unknown type variable"
    in [Axiom_Class (UL.bind [] ([], show n , map (\t -> maybe (err) var $ lookup (show $ makeTpSchemeFromType t) classBetas) types))]

replaceTypeVariables :: [(String, TyVar)] -> [(String, TyVar)] -> PolyType -> PolyType
replaceTypeVariables mapping [] pt              = pt
replaceTypeVariables mapping ((n, b):rst) pt    = UL.substs (maybe [] (\v -> [(v, var b)]) (lookup n mapping)) (replaceTypeVariables mapping rst pt)

combineSubsitutions :: [(String, MonoType)] -> [(String, TyVar)] -> [(Integer, Integer)] -> [(TyVar, MonoType)]
combineSubsitutions [] _ _ = []
combineSubsitutions ((s,tv):rst) mapping fmapping = (combineSubsitutions rst mapping fmapping) ++ 
    fromMaybe [] (
        do
            parsedTV <- lookup s mapping
            let parsedInt = UL.name2Integer parsedTV
            replacedTV <- lookup parsedInt fmapping
            return $ [(integer2Name replacedTV, tv)] 
    )


}

ATTR SimpleType [ | | name:Name typevariables:Names ]

SEM SimpleType
  | SimpleType  lhs . name          = @name.self
                    . typevariables = @typevariables.self

ATTR Pattern    [ | | beta : TyVar ]
ATTR Patterns   [ | | betas : {[TyVar]} numberOfPatterns:Integer ]


SEM Patterns
  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . numberOfPatterns = 1 + @tl.numberOfPatterns
          . resultTypes       = @hd.resultTypes ++ @tl.resultTypes
  | Nil
      lhs . betas            = []
          . numberOfPatterns = 0
          . resultTypes      = []
SEM Pattern
    | Variable
        lhs . touchables    = [@beta]
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . environment   = M.singleton @name.self @beta
        loc . beta          = UL.makeName (show @name.self) @lhs.betaUnique
    | Literal
        lhs . touchables    = [@beta]
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType]
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
    | Tuple
        patterns    . betaUnique        = @lhs.betaUnique + 1
        lhs         . constraints       = @constraint : @patterns.constraints
        lhs         . touchables        = @beta : @patterns.touchables
        loc         . beta              = integer2Name @lhs.betaUnique
                    . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @patterns.betas))
    | Wildcard
        lhs         . touchables        = [@beta]
        lhs         . betaUnique        = @lhs.betaUnique + 1
        loc         . beta              = integer2Name @lhs.betaUnique
    | List 
        lhs         . touchables        = @beta : @elemBeta : @patterns.touchables
        lhs         . constraints       = @lstConstraints ++ @patterns.constraints
        patterns    . betaUnique        = @lhs.betaUnique + 2
        loc         . beta              = integer2Name @lhs.betaUnique
        loc         . elemBeta          = integer2Name (@lhs.betaUnique + 1)
        loc         . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) : map (unifyVar @elemBeta) @patterns.betas
    | Constructor
        patterns    . betaUnique        = @bu2
        lhs . gadtUsed                  = @ct == ConstructorGADT || @patterns.gadtUsed
        lhs . touchables                = @beta : @betaCon : (
                                             if @ct == ConstructorRegular then 
                                                []
                                             else
                                                getTypeVariablesFromMonoType @rt 
                                            ) ++ getTypeVariablesFromPolyType' @tp ++ @patterns.touchables
        lhs . constraints               =   if @ct == ConstructorRegular then 
                                                @conApply : @conConstraints ++ @patterns.constraints
                                            else
                                                [Constraint_Unify (var @beta) @rt]
        lhs . gadtCondition             = [@conApply]
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . betaCon                   = integer2Name (@lhs.betaUnique + 1)
        loc . conApply                  = Constraint_Unify (var @betaCon) (foldr (:-->:) (var @beta) (map var @patterns.betas))
        loc . conConstraints            = [Constraint_Inst (var @betaCon) (Helium.StaticAnalysis.Inferencers.OutsideInX.TypeInferencing.bindTypeVariables (getTypeVariablesFromMonoType (getRHSPT @tp)) @tp)]
        loc . gadtVariables             =   if @ct == ConstructorRegular then 
                                                []
                                            else
                                                --@beta : @betaCon : getTypeVariablesFromPolyType' @tp ++ @patterns.touchables
                                                @beta : @betaCon : @patterns.touchables ++ getTypeVariablesFromMonoType (getRHSPT @tp)
        loc . gadtAssumeConstraints     =   if @ct == ConstructorRegular then 
                                                []
                                            else
                                                 @conConstraints ++ [Constraint_Unify (var @betaCon) @conrt] ++ @resConstraints ++ @patterns.constraints
        loc . ((tp, bu), ct)            = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                            Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                            Just (ctp, ct) -> (freshen (@lhs.betaUnique + 2) $ unbindPolyType $ tpSchemeToPolyType (importEnvironmentToTypeFamilies @lhs.importEnvironment) ctp, ct)
        loc . ((rt, conrt, resConstraints), bu2) = freshen (@bu + 1) $ getResultType @tp

    | InfixConstructor
        leftPattern . betaUnique        = @bu
        lhs . touchables                = @beta : @betaCon : @leftPattern.touchables ++ @rightPattern.touchables ++ getTypeVariablesFromPolyType' @tp
        lhs . constraints               = @conApply : @conConstraints ++ @leftPattern.constraints ++ @rightPattern.constraints
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . betaCon                   = integer2Name (@lhs.betaUnique + 1)
        loc . conApply                  = Constraint_Unify (var @betaCon) (var @leftPattern.beta :-->: (var @rightPattern.beta :-->: var @beta))
        loc . (tp, bu)                  = case M.lookup @constructorOperator.self (valueConstructors @lhs.importEnvironment) of
                                            Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                            Just (ctp, _) -> freshen (@lhs.betaUnique + 2) $ tpSchemeToPolyType (importEnvironmentToTypeFamilies @lhs.importEnvironment) ctp
        loc . conConstraints            = [Constraint_Inst (var @betaCon) @tp]
    | As
        pattern . betaUnique            = @lhs.betaUnique + 1
        lhs . touchables                = @beta : @pattern.touchables
        lhs . constraints               = unifyVar @beta @pattern.beta : @pattern.constraints
        lhs . environment               = M.insert @name.self @beta @pattern.environment
        loc . beta                      = integer2Name @lhs.betaUnique
    | Negate 
        literal . betaUnique            = @bu
        lhs . touchables                = @beta : @literal.touchables
        lhs . constraints               = [Constraint_Inst (@literal.literalType :-->: var @beta) @tp] ++ @literal.constraints
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . (tp, bu)                  =   let standard = PolyType_Mono [Constraint_Class "Num" [var $ integer2Name 0]] ((var $ integer2Name 0) :-->: (var $ integer2Name 0))
                                            in freshen (@lhs.betaUnique + 1) $ M.findWithDefault standard (nameFromString "negate") (tpSchemeToPolyType (importEnvironmentToTypeFamilies @lhs.importEnvironment) <$> typeEnvironment @lhs.importEnvironment)
    | NegateFloat
        lhs . betaUnique  = @lhs.betaUnique + 1
        lhs . touchables  = @beta : @literal.touchables
        loc . constraints = [ Constraint_Unify (MonoType_Con "Float") (var @beta)] ++ @literal.constraints
            . beta        = integer2Name @lhs.betaUnique


{

getRHSPT :: PolyType -> MonoType
getRHSPT (PolyType_Mono _ m) = getRHS m

getRHS :: MonoType -> MonoType
getRHS (f :-->: a) = getRHS a
getRHS x = x

getResultType :: PolyType -> (MonoType, MonoType, [Constraint])
getResultType x = getResultTypeHelper 0 x

getResultTypeHelper :: Integer -> PolyType -> (MonoType, MonoType, [Constraint])
getResultTypeHelper i (PolyType_Mono cs m) = (\(mr, m, c, _) -> (mr, m, c ++ cs)) (getResultTypeM i m)
getResultTypeHelper i (PolyType_Bind b) = contFreshM (UL.unbind b >>= (\(t, x) -> return $ getResultTypeHelper (UL.name2Integer t + 1) x)) i

getResultTypeM :: Integer -> MonoType -> (MonoType, MonoType, [Constraint], Integer)
getResultTypeM i (f :-->: a) = let 
                                    (_, m1, cs1, i1) = getResultTypeM i f
                                    (r, m2, cs2, i2) = getResultTypeM i1 a
                                in (r, m1 :-->: m2, cs1 ++ cs2, i2) 
getResultTypeM i (MonoType_App y x) =  let 
                                    (m1, cs1, i1) = getResultTypeM' i y 
                                    (m2, cs2, i2) = getResultTypeM' i1 x
                                in (MonoType_App m1 m2, MonoType_App m1 m2, cs1 ++ cs2, i2) 
getResultTypeM i (MonoType_Con s)   = let v = var $ integer2Name i in (v, v, [Constraint_Unify v (MonoType_Con s)], i + 1)
getResultTypeM i f@(MonoType_Fam _ _) = (f, f, [], i)
getResultTypeM i (MonoType_Var v)   = (internalError "TypeInferenceRules" "getResultTypeM" "Return type of a GADT can never be a type variable", MonoType_Var v, [], i)

getResultTypeM' :: Integer -> MonoType -> (MonoType, [Constraint], Integer)
getResultTypeM' i (MonoType_Var v) = (MonoType_Var v, [], i)
getResultTypeM' i (MonoType_Con "->") = (MonoType_Con "->", [], i)
getResultTypeM' i (MonoType_Con c) = (MonoType_Var (integer2Name i), [Constraint_Unify (var $ integer2Name i) (MonoType_Con c)], i + 1) 
getResultTypeM' i (MonoType_App x y) = let 
                                    (m1, cs1, i1) = getResultTypeM' i x
                                    (m2, cs2, i2) = getResultTypeM' i1 y
                                in (MonoType_App m1 m2, cs1 ++ cs2, i2) 
}
        
SEM FunctionBinding 
    | FunctionBinding
        lhs . touchables        = @lefthandside.touchables ++ @righthandside.touchables
        lhs . assumptions       = if null @lefthandside.gadtVariables then @assumptions else M.empty
        lhs . constraints       =   if null @lefthandside.gadtVariables then 
                                       @lefthandside.constraints ++ @righthandside.constraints  ++ @assConstraints ++ @locConstraints
                                    else
                                        @lefthandside.constraints ++ @locConstraints
        lhs . gadtConstraints   =   if null @lefthandside.gadtVariables then 
                                        @subGADTConstraints 
                                    else
                                        [GADTConstraint 
                                            (@righthandside.touchables ++ @lefthandside.gadtVariables) 
                                            @lefthandside.gadtAssumeConstraints
                                            (@lefthandside.gadtCondition ++ @righthandside.constraints ++ @assConstraints)
                                            @assumptions
                                            @subGADTConstraints
                                        ]
                                    
        lhs . name              = @lefthandside.name
        lhs . numberOfPatterns  = @lefthandside.numberOfPatterns
        loc . assumptions       = @righthandside.assumptions M.\\ @lefthandside.environment
        loc . locConstraints    = zipWith (\bt bb -> Constraint_Unify (var bb) (var bt) ) @lhs.betasLeft @lefthandside.betas
        loc . assConstraints     = (concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Inst (var a') (var e) | (_, a') <- a]) 
                                        @righthandside.assumptions @lefthandside.environment) ++ [Constraint_Unify (var @lhs.betaRight) (var @righthandside.beta)]
        loc . subGADTConstraints = map (resolveEnv @lefthandside.environment) @righthandside.gadtConstraints

{

resolveEnv :: Environment -> GADTConstraint -> GADTConstraint
resolveEnv env c = c{
        gadtImplication = gadtImplication c ++ (concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Inst (var a') (var e) | (_, a') <- a]) (gadtAssumptions c) env),
        gadtAssumptions = gadtAssumptions c M.\\ env,
        gadtSubGADTConstraints = map (resolveEnv env) (gadtSubGADTConstraints c)
    }

}

ATTR FunctionBinding LeftHandSide Pattern Patterns 
    [ 
    | 
    |
        gadtVariables USE {(++)} {[]} : {[TyVar]}
        gadtCondition USE {(++)} {[]} : {[Constraint]}
        gadtAssumeConstraints USE {(++)} {[]} : {[Constraint]}
        resultTypes : {[MonoType]}
    ]        

SEM FunctionBindings

  | Cons
        lhs . numberOfPatterns  = @hd.numberOfPatterns
            . name              = @hd.name
  | Nil
        lhs . numberOfPatterns  = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
            . name              = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"


ATTR LeftHandSide   [ | | name : {Name} betas : {[TyVar]} numberOfPatterns:Integer ]

SEM LeftHandSide
    | Function
        lhs . betas             = @patterns.betas
        lhs . numberOfPatterns  = @patterns.numberOfPatterns
        lhs . name              = @name.self
    | Infix
        lhs . betas             = [@leftPattern.beta, @rightPattern.beta]
        lhs . numberOfPatterns  = 2
        lhs . name              = @operator.self
    | Parenthesized
        lhs . betas = @lefthandside.betas ++ @patterns.betas
        lhs . numberOfPatterns = @lefthandside.numberOfPatterns + @patterns.numberOfPatterns

ATTR RightHandSide  [ betaRight : TyVar | | beta : TyVar]

SEM RightHandSide
    | Expression
        lhs     . gadtConstraints = @where.gadtConstraints
        lhs     . assumptions = @where.assumptions
                . constraints = unifyVar @lhs.betaRight @expression.beta : @where.constraints
        where   . assumptions = @expression.assumptions
                . constraints = @expression.constraints
    | Guarded
        lhs                 . beta           = @lhs.betaRight
        lhs                 . assumptions    = @where.assumptions
                            . constraints    = @where.constraints
        guardedexpressions  . numberOfGuards = length @guardedexpressions.self
        where               . assumptions    = @guardedexpressions.assumptions
                            . constraints    = @guardedexpressions.constraints

ATTR GuardedExpressions GuardedExpression [ betaRight:TyVar | | beta : TyVar]

SEM GuardedExpression

  | GuardedExpression
      lhs . constraints = [Constraint_Unify (var @guard.beta) (MonoType_Con "Bool"), (unifyVar @expression.beta @lhs.betaRight)] ++ @guard.constraints ++ @expression.constraints

ATTR MaybeDeclarations [ | touchables : Touchables assumptions:Assumptions constraints:Constraints gadtConstraints : GADTConstraints| ]

SEM MaybeDeclarations
    | Just
        lhs . touchables        = if isJust @lhs.className then @declarations.touchables ++ @lhs.touchables else @touchables1
        lhs . constraints       = if isJust @lhs.className then @declarations.constraints else @constraints1
        lhs . bindingGroups     = if isJust @lhs.className then @declarations.bindingGroups else []
        lhs . assumptions       = if isJust @lhs.className then @declarations.assumptions else @assumptions1
        lhs . typeSignatureCollect = if isJust @lhs.className then @declarations.typeSignaturesCollect else @typeSignatureCollect1
        lhs . typeErrors        = if isJust @lhs.className then @declarations.typeErrors else @typeErrors1
        lhs . betaUnique        = if isJust @lhs.className then @declarations.betaUnique else @bu1
        lhs . resolvedContraints = if isJust @lhs.className then @declarations.resolvedContraints else @resolvedContraints1
        (
            loc . touchables1,
            loc . assumptions1,
            loc . typeSignaturesCollect1,
            loc . constraints1,
            loc . bu1,
            _,
            loc . typeErrors1,
            loc . resolvedContraints1
        ) = @bgResult
        loc . bgResult = 
                if isJust @lhs.className then 
                    let err x = error $ "Should not need where" ++ show x
                    in (err 1, err 2, err 3, err 4, err 5, err 6, err 7, err 8)
                else let 
                    inputBDG = (False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @lhs.touchables, Just (@lhs.assumptions, @lhs.constraints, @lhs.gadtConstraints), @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
                in bindingGroupAnalysis inputBDG @declarations.bindingGroups



ATTR Expression MaybeExpression [ | | beta : TyVar]
ATTR Expressions [ | | betas : {[TyVar]} nrOfExpressions : Integer]

SEM Expressions
    | Cons
        lhs . betas = @hd.beta : @tl.betas
        lhs . nrOfExpressions = @tl.nrOfExpressions + 1
    | Nil 
        lhs . betas = []
        lhs . nrOfExpressions = 0


SEM Expression
    | Literal
        lhs . betaUnique    = @lhs.betaUnique + 1
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType]
        lhs . touchables    = [@beta]
    | Variable
        lhs . touchables    = [@beta]
        loc . beta          = UL.makeName (show @name.self) @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . assumptions   = M.singleton @name.self [(@name.self, @beta)]
    | NormalApplication
        loc . beta              = integer2Name @lhs.betaUnique
        function . betaUnique   = @lhs.betaUnique + 1
        lhs . touchables        = @beta : @function.touchables ++ @arguments.touchables
        lhs . constraints       = [@constraint] ++ @function.constraints ++ @arguments.constraints
        loc . constraint        = Constraint_Unify (var @function.beta) (foldr (:-->:) (var @beta) (map var @arguments.betas))
    | If
        lhs . constraints       = @constraints ++ concat [@guardExpression.constraints, @thenExpression.constraints, @elseExpression.constraints]
        lhs . touchables        = @beta : concat [ @guardExpression.touchables, @thenExpression.touchables, @elseExpression.touchables ]
        guardExpression.betaUnique = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . constraints       =   [
                                        Constraint_Unify (var @guardExpression.beta) (MonoType_Con "Bool"),
                                        unifyVar @beta @thenExpression.beta,
                                        unifyVar @beta @elseExpression.beta 
                                    ]
    | Lambda
        lhs . touchables        = @beta : @expression.touchables ++ @patterns.touchables
        lhs . constraints       = @fConstraint : @envConstraints ++ @expression.constraints ++ @patterns.constraints
        lhs . assumptions       = @expression.assumptions M.\\ @patterns.environment
        loc . envConstraints    = concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Unify (var a') (var e) | (_, a') <- a]) @expression.assumptions @patterns.environment
        patterns . betaUnique   = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . fConstraint       = Constraint_Unify (foldr ((:-->:).var) (var @expression.beta) @patterns.betas) (var @beta)
    | Tuple
        lhs . touchables        = @beta : @expressions.touchables
        lhs . constraints       = @constraint : @expressions.constraints
        loc . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @expressions.betas))
        loc . beta              = integer2Name @lhs.betaUnique
        expressions . betaUnique = @lhs.betaUnique + 1
    | List
        lhs . touchables        = @elemBeta : @beta : @expressions.touchables
        lhs . constraints       = @lstConstraints ++ @expressions.constraints
        expressions . betaUnique = @lhs.betaUnique + 2
        loc . elemBeta          = integer2Name @lhs.betaUnique
        loc . beta              = integer2Name (@lhs.betaUnique + 1)
        loc . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) : map (unifyVar @elemBeta) @expressions.betas
    | Constructor
        lhs . touchables        = @beta : getTypeVariablesFromPolyType' @tp
        lhs . betaUnique        = @bu
        loc . (tp, bu)          = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                    Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                    Just (ctp, _) -> freshen (@lhs.betaUnique + 1) $ tpSchemeToPolyType (importEnvironmentToTypeFamilies @lhs.importEnvironment) ctp
        lhs . constraints       = [Constraint_Inst (var @beta) @tp]
        loc . beta              = integer2Name @lhs.betaUnique
    | InfixApplication
        leftExpression . betaUnique = @lhs.betaUnique + 2
        lhs . touchables            = @beta : @betaResOp : @leftExpression.touchables ++ @operator.touchables ++ @rightExpression.touchables
        lhs . constraints           = @constraints ++ @leftExpression.constraints ++ @operator.constraints ++ @rightExpression.constraints
        loc . beta                  = integer2Name @lhs.betaUnique
        loc . betaResOp             = integer2Name $ @lhs.betaUnique + 1 
    	loc . conOperator           = Constraint_Unify (var @operator.beta) (var @leftExpression.beta :-->: (var @rightExpression.beta :-->: var @betaResOp))
        loc . constraints           = case (@leftExpression.section,@rightExpression.section) of
                                                (False,False) -> [ @conOperator, (unifyVar @betaResOp @beta)                        ]
                                                (True ,True ) -> [               (unifyVar @operator.beta @beta)                        ]
                                                (False,True ) -> [ @conOperator, (Constraint_Unify (var @rightExpression.beta :-->: var @betaResOp) (var @beta)) ]
                                                (True ,False) -> [ @conOperator, (Constraint_Unify (var @leftExpression.beta  :-->: var @betaResOp) (var @beta)) ]
    | Let
        declarations.betaUnique = @lhs.betaUnique + 1
        lhs . touchables        = @beta : @touchables
        lhs . constraints       = unifyVar @beta @expression.beta : @constraints
        lhs . bindingGroups     = []
        loc . beta              = integer2Name @lhs.betaUnique
        (
            loc . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            loc . constraints,
            lhs . betaUnique,
            _,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let !inputBDG = (False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @expression.touchables, Just (@expression.assumptions, @expression.constraints, @expression.gadtConstraints),  @declarations.typeErrors ++ @expression.typeErrors, @declarations.resolvedContraints ++ @expression.resolvedContraints ,@expression.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups
    | Case
        lhs . touchables              = @beta : @beta' : @expression.touchables ++ @alternatives.touchables
        lhs . constraints             = unifyVar @expression.beta @beta' : @expression.constraints ++ @alternatives.constraints
        expression      . betaUnique  = @lhs.betaUnique + 2
        alternatives    . betaLeft    = @beta'
                        . betaRight   = @beta
        loc             . beta        = integer2Name @lhs.betaUnique
                        . beta'       = integer2Name $ @lhs.betaUnique + 1
    | Typed 
        expression . betaUnique = @bu
        lhs . touchables    = @beta : @expression.touchables
        lhs . constraints   =   [
                                    unifyVar @beta @expression.beta,
                                    Constraint_Inst (var @beta) @tp
                                ] ++ @expression.constraints
        loc . beta          = integer2Name @lhs.betaUnique
        loc . (tp, bu, mapping)      = typeToPolytype (importEnvironmentToTypeFamilies @lhs.importEnvironment) (@lhs.betaUnique + 1) @type.self
    | Comprehension
        lhs . constraints           = @newcon : @qualifiers.constraints
        lhs . touchables            = @beta : @expression.touchables ++ @qualifiers.touchables
        expression  . betaUnique    = @lhs.betaUnique + 1
        qualifiers  . assumptions   = @expression.assumptions
                    . constraints   = @expression.constraints
        loc         . assumptions   = @qualifiers.assumptions
                    . beta          = integer2Name @lhs.betaUnique
                    . newcon        = Constraint_Unify (monotypeList (var @expression.beta)) (var @beta)
    | Enum
        loc . beta                  = integer2Name @lhs.betaUnique
        loc . betaElem              = integer2Name $ @lhs.betaUnique + 1
        from . betaUnique           = @lhs.betaUnique + 2
        lhs . touchables            = @beta : @betaElem : @from.touchables ++ @then.touchables ++ @to.touchables
        lhs . constraints           =   [
                                            Constraint_Unify (monotypeList (var @betaElem)) (var @beta),
                                            Constraint_Unify (var @betaElem) (var @from.beta),
                                            Constraint_Unify (var @betaElem) (var @then.beta),
                                            Constraint_Unify (var @betaElem) (var @to.beta),
                                            Constraint_Class "Enum" [var @betaElem]
                                        ] ++ @from.constraints ++ @then.constraints ++ @to.constraints
    | Negate  
        expression . betaUnique     =   @lhs.betaUnique + 1
        lhs . touchables            =   @beta : @expression.touchables
        lhs . constraints           =   [Constraint_Inst (var @expression.beta :-->: var @beta) @tp ] ++ @expression.constraints
        loc . beta                  =   integer2Name @lhs.betaUnique
        loc . (tp, bu)              =   let standard = PolyType_Mono [Constraint_Class "Num" [var $ integer2Name 0]] ((var $ integer2Name 0) :-->: (var $ integer2Name 0))
                                        in freshen (@lhs.betaUnique + 1) $ M.findWithDefault standard (nameFromString "negate") (tpSchemeToPolyType (importEnvironmentToTypeFamilies @lhs.importEnvironment) <$> typeEnvironment @lhs.importEnvironment)
    | NegateFloat 
        expression . betaUnique     = @lhs.betaUnique + 1
        lhs . touchables            = @beta : @expression.touchables
        lhs . constraints           = [Constraint_Unify (MonoType_Con "Float" :-->: MonoType_Con "Float") (var @expression.beta :-->: var @beta)] ++ @expression.constraints
        loc . beta                  = integer2Name @lhs.betaUnique

    | Do 
        statements . betaUnique     = @lhs.betaUnique + 3
        statements . generatorBeta  = Nothing
        statements . monadBeta      = var @betaMonad
        statements . assumptions    = M.empty
        statements . constraints    = []
        statements . touchables     = []
        statements . gadtConstraints= []
        loc . beta                  = integer2Name @lhs.betaUnique
        loc . betaMonad             = integer2Name $ @lhs.betaUnique + 1
        loc . betaVar               = integer2Name $ @lhs.betaUnique + 2
        lhs . constraints           =   [
                                            Constraint_Unify (var @beta) (MonoType_App (var @betaMonad) (var @betaVar)),
                                            Constraint_Class "Monad" [var @betaMonad]
                                        ] ++ maybe [] (\b -> [Constraint_Unify (var @beta) (var b)]) @statements.generatorBeta ++ @statements.constraints
                                        

ATTR Statements Statement [ monadBeta : {MonoType} | touchables : {[TyVar]} generatorBeta : {Maybe TyVar} assumptions : Assumptions constraints:Constraints substitutionCollect : Substitution gadtConstraints : GADTConstraints | ]

SEM Statement 
    | Expression
        expression . betaUnique = @lhs.betaUnique + 2
        loc . beta              = integer2Name @lhs.betaUnique
        loc . betaRes           = integer2Name $ @lhs.betaUnique + 1
        lhs . generatorBeta     = Just @beta
        lhs . touchables        = @beta : @betaRes : @expression.touchables ++ @lhs.touchables
        lhs . assumptions       = @lhs.assumptions `combineAssumptions` @expression.assumptions
        lhs . constraints       =   [
                                        Constraint_Unify (var @expression.beta) (var @beta), 
                                        Constraint_Unify (var @beta) (MonoType_App @lhs.monadBeta (var @betaRes))
                                    ] ++ @expression.constraints ++ @lhs.constraints
    | Generator 
        lhs . generatorBeta         = Nothing
        lhs . betaUnique            = @expression.betaUnique
        lhs . assumptions           = @assumptions' `combineAssumptions` @expression.assumptions
        lhs . constraints           = Constraint_Unify (var @expression.beta) (MonoType_App @lhs.monadBeta (var @pattern.beta)) : 
                                            @envConstraints ++ @expression.constraints ++ @pattern.constraints ++ @lhs.constraints
        lhs . touchables            = @expression.touchables ++ @pattern.touchables ++ @lhs.touchables
        pattern . betaUnique        = @lhs.betaUnique + 2
        expression . betaUnique     = @pattern.betaUnique
        loc . assumptions'          = @lhs.assumptions M.\\ @pattern.environment
        loc . envConstraints        = concat $ M.elems (M.intersectionWith (\a' e -> [unifyVar a e | (_, a) <- a']) @lhs.assumptions @pattern.environment)
    | Let 
        lhs . generatorBeta  = Nothing
        declarations . bindingGroups = []
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            lhs . constraints,
            lhs . betaUnique,
            _,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let !inputBDG = (False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @lhs.touchables, Just (@lhs.assumptions, @lhs.constraints, @lhs.gadtConstraints), @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups

SEM Statements

    | Cons
        lhs . assumptions = @hd.assumptions
            . constraints = @hd.constraints
            . touchables  = @hd.touchables
            . betaUnique = @hd.betaUnique
        hd  . assumptions = @tl.assumptions
            . constraints = @tl.constraints
            . touchables  = @tl.touchables
            . betaUnique = @tl.betaUnique
        tl  . assumptions = @lhs.assumptions
            . constraints = @lhs.constraints
            . touchables = @lhs.touchables
            . betaUnique = @lhs.betaUnique

ATTR Alternative Alternatives [ betaLeft:TyVar betaRight:TyVar | | ]

SEM Alternative
    | Alternative
        lhs . gadtVariables = []
        lhs . constraints = if null @pattern.gadtVariables then 
                                unifyVar @pattern.beta @lhs.betaLeft : @envConstraints ++ @pattern.constraints ++ @righthandside.constraints
                            else
                                [unifyVar @pattern.beta @lhs.betaLeft]
        lhs . assumptions = if null @pattern.gadtVariables then @assumptions else M.empty
        loc . assumptions =  @righthandside.assumptions M.\\ @pattern.environment
        loc . envConstraints = concat $ M.elems (M.intersectionWith (\a' e -> [unifyVar a e | (_, a) <- a']) @righthandside.assumptions @pattern.environment)
        lhs . gadtConstraints = if null @pattern.gadtVariables then 
                                    @subGADTConstraints 
                                else
                                    [GADTConstraint
                                        (@righthandside.touchables ++ @pattern.gadtVariables)
                                        @pattern.gadtAssumeConstraints
                                        (@pattern.gadtCondition ++ @righthandside.constraints ++ @envConstraints)
                                        @assumptions
                                        @subGADTConstraints
                                    ]
                                     
        loc . subGADTConstraints = map (resolveEnv @pattern.environment) @righthandside.gadtConstraints

ATTR Qualifier Qualifiers [ |  touchables : {[TyVar]} assumptions:Assumptions constraints:Constraints substitutionCollect : Substitution gadtConstraints : GADTConstraints | ]

SEM Qualifier
    | Guard
        lhs . touchables = @guard.touchables ++ @lhs.touchables
        lhs . assumptions = @lhs.assumptions `combineAssumptions` @guard.assumptions
        lhs . constraints =  Constraint_Unify (var @guard.beta) (MonoType_Con "Bool") : @guard.constraints ++ @lhs.constraints
    | Generator
        lhs . touchables        = @expression.touchables ++ @pattern.touchables ++ @lhs.touchables
        lhs . assumptions       = @assumptions' `combineAssumptions` @expression.assumptions
        lhs . constraints       = @newcon : @envConstraints ++ @pattern.constraints ++ @expression.constraints ++ @lhs.constraints
        loc . newcon            = Constraint_Unify (var @expression.beta) $ monotypeList (var @pattern.beta)
        loc . assumptions'      = @lhs.assumptions M.\\ @pattern.environment
        loc . envConstraints    = concat $ M.elems (M.intersectionWith (\a' e -> [unifyVar a e | (_, a) <- a']) @lhs.assumptions @pattern.environment)
    | Let
        lhs . bindingGroups     = []
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            lhs . constraints,
            lhs . betaUnique,
            _,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let !inputBDG = (False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @lhs.touchables, Just (@lhs.assumptions, @lhs.constraints, @lhs.gadtConstraints), @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups

SEM Qualifiers

  | Cons
        lhs . assumptions = @hd.assumptions
            . constraints = @hd.constraints
            . touchables  = @hd.touchables
            . betaUnique = @hd.betaUnique
        hd  . assumptions = @tl.assumptions
            . constraints = @tl.constraints
            . touchables  = @tl.touchables
            . betaUnique = @tl.betaUnique
        tl  . assumptions = @lhs.assumptions
            . constraints = @lhs.constraints
            . touchables = @lhs.touchables
            . betaUnique = @lhs.betaUnique



ATTR MaybeExpression [ | | section : Bool]          

SEM MaybeExpression

  | Just
      lhs . section = False

  | Nothing
      lhs . touchables  = [@beta]
      lhs . section     = True
          . betaUnique  = @lhs.betaUnique + 1
      loc . beta        = integer2Name @lhs.betaUnique
      


ATTR Literal [ | | literalType : MonoType]

SEM Literal
    | Int
        lhs . literalType   = MonoType_Con "Int"
    | Float
        lhs . literalType   = MonoType_Con "Float"
    | String
        lhs . literalType   = MonoType_Fam "String" []
    | Char
        lhs . literalType   = MonoType_Con "Char"
              
{

}

