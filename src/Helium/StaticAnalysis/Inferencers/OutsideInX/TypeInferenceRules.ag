
ATTR Module Body Declaration Declarations Expression Expressions
     GuardedExpression GuardedExpressions MaybeDeclarations
     MaybeExpression Qualifier Qualifiers RecordExpressionBinding
     RightHandSide Alternative Alternatives FunctionBinding
     FunctionBindings Statement RecordExpressionBindings
     Statements AnnotatedType Types Constructor AnnotatedTypes 
     ContextItem FieldDeclaration Constructors ContextItems 
     FieldDeclarations Type Literal LeftHandSide RightHandSide
     Pattern Patterns
        [ 
                typeSignatures : {M.Map Name (TyVar, PolyType)}
                substitution : {[(TyVar, MonoType)]}
                importEnvironment : ImportEnvironment
            |   betaUnique : Integer
            |   assumptions USE {M.unionWith (++)} {M.empty} : {M.Map Name [(Name, TyVar)]}
                environment USE {M.union} {M.empty} : {M.Map Name TyVar}
                constraints USE {(++)} {[]} : {[Constraint]}
                bindingGroups USE {(++)} {[]} : {[BindingGroup]}
                touchables USE {(++)} {[]} : {[(Maybe Name, TyVar)]}
                toplevelTypes USE {M.union} {M.empty}  : TypeEnvironment
                typeSignaturesCollect USE {M.union} {M.empty} : {M.Map Name (TyVar, PolyType)}
                typeErrors USE {(++)} {[]} : TypeErrors
                substitutionCollect USE {(++)} {[]} : {[(TyVar, MonoType)]}
                tlEnvironment USE {M.union} {M.empty} : {M.Map Name TyVar}
        ]

ATTR Body Declaration Declarations MaybeDeclarations FunctionBinding FunctionBindings LeftHandSide RightHandSide Expression Expressions MaybeExpression
        GuardedExpressions GuardedExpression Pattern Patterns Alternative Alternatives
            [   monos:Monos 
            |   
            |
            ]

ATTR Declaration Declarations                   [ inheritedBDG:InheritedBDG | | inheritedBDGCollect : InheritedBDG ]
{

unifyVar :: TyVar -> TyVar -> Constraint
unifyVar v1 v2 = Constraint_Unify (var v1) (var v2)

substitutePoly :: TyVar -> [(TyVar, MonoType)] -> MonoType
substitutePoly v env = case lookup v env of
    Nothing -> error $ "Cannot provide substitution for " ++ show v
    Just m -> m

bindTypeVariables :: [TyVar] -> PolyType -> PolyType
bindTypeVariables = flip (foldr ((PolyType_Bind .) . UL.bind))

type SolveResult = ([TypeError], [Warning], [(TyVar, MonoType)])

constructErrors :: (Either NamedSolverError Solution, Graph) -> SolveResult
constructErrors (et, _) = either (\e -> (makeTypeError e, [], [])) (\solution -> ([], [], substitution solution)) et

getTypeErrors :: SolveResult -> [TypeError]
getTypeErrors (te, _, _) = te

getWarnings :: SolveResult -> [Warning]
getWarnings (_, wa, _) = wa

getSubstitution :: SolveResult -> [(TyVar, MonoType)]
getSubstitution (_, _, subs) = subs


}

SEM Module
    | Module
        lhs . dictionaryEnvironment = trace (unlines $ map show $ getSubstitution @solveResults) emptyDictionaryEnvironment
        lhs . toplevelTypes = if null @typeErrors then @body.toplevelTypes else M.empty -- 
        loc . typeErrors = getTypeErrors @solveResults ++ @body.typeErrors
        lhs . warnings = getWarnings @solveResults
        body . betaUnique = 1
        body . substitution = getSubstitution @solveResults
        body . monos = []
        loc . constrs = @body.constraints ++  map (uncurry (Constraint_Unify . var)) @body.substitutionCollect
        loc . tyvars = map snd @body.touchables
        loc . solveResults = constructErrors $ runFreshM $ solve [] [] @constrs @tyvars
        body . typeSignatures = (M.map (\tps -> (integer2Name (-1), PolyType_Mono [] $ tpSchemeToMonoType tps)) $ typeEnvironment @lhs.importEnvironment)

SEM Body
    | Body
        declarations . bindingGroups    = []
        -- lhs . toplevelTypes = M.map (monoTypeToTypeScheme.getMonoFromPoly.snd) @lhs.typeSignatures `M.union` M.map (monoTypeToTypeScheme.getMonoFromPoly.snd) @typeSignatures
        declarations . betaUnique = @lhs.betaUnique
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            lhs . constraints,
            lhs . betaUnique,
            lhs . substitutionCollect,
            lhs . typeErrors,
            loc . iBDG
        ) =
            let inputBDG = (True, @declarations.typeSignaturesCollect `M.union` @lhs.typeSignatures, [], @declarations.touchables, Nothing, @declarations.betaUnique)
            in  bindingGroupAnalysis2 inputBDG @declarations.bindingGroups

ATTR FunctionBinding FunctionBindings [ betasLeft : {[TyVar]} betaRight : TyVar | | name : Name numberOfPatterns : Integer  ]

SEM Declaration
    | FunctionBindings
        lhs . betaUnique        = @bindings.betaUnique
        lhs . bindingGroups     = [@bindingGroup]
        lhs . substitutionCollect = []
        loc . bindingGroup      = (@environment, @assumptions, @constraints, @bindings.substitutionCollect)
        lhs . toplevelTypes     = M.singleton (@bindings.name) (maybe @err monoTypeToTypeScheme $ lookup @beta @lhs.substitution)
        lhs . tlEnvironment           = @environment
        loc . environment       = M.singleton @bindings.name @beta
        loc . assumptions       = @bindings.assumptions
        lhs . touchables        = (Just @bindings.name, @beta) : (Nothing, @br) : map (\x -> (Nothing,x)) @bls ++ @bindings.touchables
        loc . constraints       = @parameterCons ++ @bindings.constraints 
        loc . bls               = take (fromInteger @bindings.numberOfPatterns) (map integer2Name [(@lhs.betaUnique + 2)..])
        loc . br                = integer2Name $ @lhs.betaUnique + 1
        loc . beta              = traceShow @bindings.name $ traceShowId $ integer2Name @lhs.betaUnique
        loc . parameterCons     = traceShowId [Constraint_Unify (var @beta) (foldr ((:-->:) . var) (var @br) @bls)] --++
                                    --maybe [] (\ts -> [Constraint_Unify (var @beta) (fst $ freshen (9999 :: Integer) $ getMonoFromPoly ts)]) (M.lookup @bindings.name @lhs.typeSignatures)
        loc . err               = internalError "TypeInferenceRules.ag" "FunctionBindings" ("No substitution found for " ++ show @bindings.name)
        bindings.betasLeft      = @bls 
        bindings.betaRight      = @br 
        bindings . betaUnique   = @lhs.betaUnique + 2 + @bindings.numberOfPatterns
        bindings . monos        = M.elems (@bindings.environment M.\\ @lhs.typeSignatures) ++ @lhs.monos
    | PatternBinding
        lhs . tlEnvironment     = @environment
        lhs . bindingGroups     = [@bindingGroup]
        lhs . substitutionCollect = []
        loc . bindingGroup      = (@environment, @assumptions, @constraints, @righthandside.substitutionCollect)
        lhs . toplevelTypes     = M.fromList $ map (\(n, v) -> (n, monoTypeToTypeScheme $ substitutePoly v @lhs.substitution)) $ M.toList @pattern.environment
        lhs . touchables        = (Nothing, @beta) : @pattern.touchables ++ @righthandside.touchables
        loc . constraints       = [unifyVar @beta @pattern.beta, unifyVar @beta @righthandside.beta] ++ @pattern.constraints ++ @righthandside.constraints
        loc . environment       = @pattern.environment
        loc . assumptions       = @righthandside.assumptions
        pattern . betaUnique    = @lhs.betaUnique + 1 
        righthandside . monos   = M.elems (@pattern.environment M.\\ @lhs.typeSignatures) ++ @lhs.monos
        loc . beta              = integer2Name @lhs.betaUnique
        loc . err               = internalError "TypeInferenceRules.ag" "PatternBinding" "No substitution found for type"
    | TypeSignature
        lhs . touchables        = (Nothing, @beta) : map (\(x, _) -> (Nothing, x)) (M.elems @ts) -- ++ concatMap (getTypeVariablesFromMonoType . getMonoFromPoly . snd) @ts
        loc . beta              = integer2Name @lhs.betaUnique
        lhs . betaUnique        = @bu
        lhs . typeSignaturesCollect = @ts
        loc . (ts, bu)          = foldr (\n (m, b) -> let 
                                                (t, b') = typeToPolytype b @type.self
                                                m' = M.insert n (integer2Name b', t) m
                                            in (m', b' + 1)) (M.empty, @lhs.betaUnique + 1) $ @names.self

ATTR Pattern    [ | | beta : TyVar ]
ATTR Patterns   [ | | betas : {[TyVar]} numberOfPatterns:Integer ]


SEM Patterns
  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . numberOfPatterns = 1 + @tl.numberOfPatterns
  | Nil
      lhs . betas            = []
          . numberOfPatterns = 0
SEM Pattern
    | Variable
        lhs . touchables    = [(Just @name.self, @beta)]
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . environment   = M.singleton @name.self @beta
        loc . beta          = integer2Name @lhs.betaUnique
    | Literal
        lhs . touchables    = [(Nothing, @beta)]
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType]
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
    | Tuple
        patterns    . betaUnique        = @lhs.betaUnique + 1
        lhs         . constraints       = @constraint : @patterns.constraints
        lhs         . touchables        = (Nothing, @beta) : @patterns.touchables
        loc         . beta              = integer2Name @lhs.betaUnique
                    . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @patterns.betas))
    | Wildcard
        lhs         . touchables        = [(Nothing, @beta)]
        lhs         . betaUnique        = @lhs.betaUnique + 1
        loc         . beta              = integer2Name @lhs.betaUnique
    | List 
        lhs         . touchables        = (Nothing, @beta) : (Nothing, @elemBeta) : @patterns.touchables
        lhs         . constraints       = @lstConstraints ++ @patterns.constraints
        patterns    . betaUnique        = @lhs.betaUnique + 2
        loc         . beta              = integer2Name @lhs.betaUnique
        loc         . elemBeta          = integer2Name (@lhs.betaUnique + 1)
        loc         . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) : map (unifyVar @elemBeta) @patterns.betas
    | Constructor
        patterns    . betaUnique        = @lhs.betaUnique + 2
        lhs . touchables                = (Just @name.self, @beta) : (Just @name.self, @betaCon) : @patterns.touchables
        lhs . constraints               = @conApply : @conConstraints ++ @patterns.constraints
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . betaCon                   = integer2Name (@lhs.betaUnique + 1)
        loc . conApply                  = Constraint_Unify (var @betaCon) (foldr (:-->:) (var @beta) (map var @patterns.betas))
        loc . conConstraints            = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                                Nothing  -> []
                                                Just ctp -> [Constraint_Inst (var @betaCon) (PolyType_Mono [] $ tpSchemeToMonoType ctp)]
    | As
        pattern . betaUnique            = @lhs.betaUnique + 1
        lhs . touchables                = (Just @name.self, @beta) : @pattern.touchables
        lhs . constraints               = unifyVar @beta @pattern.beta : @pattern.constraints
        lhs . environment               = M.insert @name.self @beta @pattern.environment
        loc . beta                      = integer2Name @lhs.betaUnique

        
SEM FunctionBinding 
    | FunctionBinding
        lhs . constraints       = @locConstraints ++ @lefthandside.constraints ++ @righthandside.constraints
        lhs . name              = @lefthandside.name
        lhs . numberOfPatterns  = @lefthandside.numberOfPatterns
        lhs . assumptions       = @righthandside.assumptions M.\\ @lefthandside.environment
        loc . locConstraints    = Constraint_Unify (var @lhs.betaRight) (var @righthandside.beta) : 
                                    zipWith (\bt bb -> Constraint_Unify (var bt) (var bb)) @lhs.betasLeft @lefthandside.betas ++
                                    (concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Unify (var a') (var e) | (_, a') <- a]) @righthandside.assumptions @lefthandside.environment)
        righthandside . monos   = M.elems @lefthandside.environment ++ @lhs.monos
        

SEM FunctionBindings

  | Cons
        lhs . numberOfPatterns  = @hd.numberOfPatterns
            . name              = @hd.name
  | Nil
        lhs . numberOfPatterns  = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
            . name              = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"


ATTR LeftHandSide   [ | | name : {Name} betas : {[TyVar]} numberOfPatterns:Integer ]

SEM LeftHandSide
    | Function
        lhs . betas             = @patterns.betas
        lhs . numberOfPatterns  = @patterns.numberOfPatterns
        lhs . name              = @name.self

ATTR RightHandSide  [ | | beta : TyVar]

SEM RightHandSide
    | Expression
        lhs . beta = @expression.beta

ATTR Expression [ | | beta : TyVar]
ATTR Expressions [ | | betas : {[TyVar]} nrOfExpressions : Integer]

SEM Expressions
    | Cons
        lhs . betas = @hd.beta : @tl.betas
        lhs . nrOfExpressions = @tl.nrOfExpressions + 1
    | Nil 
        lhs . betas = []
        lhs . nrOfExpressions = 0


SEM Expression
    | Literal
        lhs . betaUnique    = @lhs.betaUnique + 1
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType]
        lhs . touchables    = [(Nothing, @beta)]
    | Variable
        lhs . touchables    = [(Just @name.self, @beta)]
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . assumptions   = M.singleton @name.self [(@name.self, @beta)]
    | NormalApplication
        loc . beta              = integer2Name @lhs.betaUnique
        function . betaUnique   = @lhs.betaUnique + 1
        lhs . touchables        = [(Nothing, @beta)] ++ @function.touchables ++ @arguments.touchables
        lhs . constraints       = [@constraint] ++ @function.constraints ++ @arguments.constraints
        loc . constraint        = Constraint_Unify (var @function.beta) (foldr (:-->:) (var @beta) (map var @arguments.betas))
    | If
        lhs . constraints       = @constraints ++ concat [@guardExpression.constraints, @thenExpression.constraints, @elseExpression.constraints]
        lhs . touchables        = (Nothing, @beta) : concat [@guardExpression.touchables, @thenExpression.touchables, @elseExpression.touchables]
        guardExpression.betaUnique = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . constraints       =   [
                                        Constraint_Unify (var @guardExpression.beta) (MonoType_Con "Bool" []),
                                        unifyVar @beta @thenExpression.beta,
                                        unifyVar @beta @elseExpression.beta 
                                    ]
    | Lambda
        lhs . touchables        = [(Nothing, @beta)] ++ @expression.touchables ++ @patterns.touchables
        lhs . constraints       = @fConstraint : @envConstraints ++ @expression.constraints ++ @patterns.constraints
        lhs . assumptions       = @expression.assumptions M.\\ @patterns.environment
        loc . envConstraints    = concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Unify (var a') (var e) | (_, a') <- a]) @expression.assumptions @patterns.environment
        patterns . betaUnique   = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . fConstraint       = Constraint_Unify (foldr ((:-->:).var) (var @expression.beta) @patterns.betas) (var @beta)
        expression . monos       = M.elems @patterns.environment ++ getMonos @envConstraints ++ @lhs.monos
    | Tuple
        lhs . touchables        = (Nothing, @beta) : @expressions.touchables
        lhs . constraints       = @constraint : @expressions.constraints
        loc . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @expressions.betas))
        loc . beta              = integer2Name @lhs.betaUnique
        expressions . betaUnique = @lhs.betaUnique + 1
    | List
        lhs . touchables        = (Nothing, @elemBeta) : (Nothing, @beta) : @expressions.touchables
        lhs . constraints       = @lstConstraints ++ @expressions.constraints
        expressions . betaUnique = @lhs.betaUnique + 2
        loc . elemBeta          = integer2Name @lhs.betaUnique
        loc . beta              = integer2Name (@lhs.betaUnique + 1)
        loc . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) : map (unifyVar @elemBeta) @expressions.betas
    | Constructor
        lhs . touchables        = (Just @name.self, @beta) : (map (\x -> (Nothing, x)) $ getTypeVariablesFromMonoType @tp)
        lhs . betaUnique        = @bu
        loc . (tp, bu)          = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                    Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                    Just ctp -> freshen (@lhs.betaUnique + 1) (tpSchemeToMonoType ctp)
        lhs . constraints       = [Constraint_Inst (var @beta) (PolyType_Mono [] @tp)]
        loc . beta              = integer2Name @lhs.betaUnique
    | Let
        declarations.betaUnique = @lhs.betaUnique + 1
        lhs . touchables        = (Nothing, @beta) : @touchables
        lhs . constraints       = unifyVar @beta @expression.beta : @constraints
        lhs . bindingGroups     = []
        loc . inheritedBDG      = []
        loc . beta              = integer2Name @lhs.betaUnique
        (
            loc . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            loc . constraints,
            lhs . betaUnique,
            lhs . substitutionCollect,
            lhs . typeErrors,
            loc . iBDG
        ) =
            let inputBDG = (False, @lhs.typeSignatures, @lhs.monos, @declarations.touchables ++ @expression.touchables, Just (@expression.assumptions, @expression.constraints, @expression.substitutionCollect), @expression.betaUnique)
            in bindingGroupAnalysis2 inputBDG @declarations.bindingGroups
            



ATTR Literal [ | | literalType : MonoType]

SEM Literal
    | Int
        lhs . literalType   = MonoType_Con "Int" []
    | Float
        lhs . literalType   = MonoType_Con "Float" []
    | String
        lhs . literalType   = MonoType_Con "String" []
    | Char
        lhs . literalType   = MonoType_Con "Char" []
              
{

}

