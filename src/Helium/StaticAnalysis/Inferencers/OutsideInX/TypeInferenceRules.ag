
ATTR Module Body Declaration Declarations Expression Expressions
     GuardedExpression GuardedExpressions
     MaybeExpression RecordExpressionBinding
     RightHandSide Alternative Alternatives FunctionBinding
     FunctionBindings Statement RecordExpressionBindings
     Statements AnnotatedType Types Constructor AnnotatedTypes 
     ContextItem FieldDeclaration Constructors ContextItems 
     FieldDeclarations Type Literal LeftHandSide RightHandSide
     Pattern Patterns
        [ 
                typeSignatures : {M.Map Name (TyVar, PolyType)}
                substitution : {[(TyVar, MonoType)]}
                importEnvironment : ImportEnvironment
                axioms : {[Axiom]}
            |   betaUnique : Integer
            |   assumptions USE {M.unionWith (++)} {M.empty} : {M.Map Name [(Name, TyVar)]}
                environment USE {M.union} {M.empty} : {M.Map Name TyVar}
                constraints USE {(++)} {[]} : {[Constraint]}
                bindingGroups USE {(++)} {[]} : {[BindingGroup]}
                touchables USE {(++)} {[]} : {[TyVar]}
                toplevelTypes USE {M.union} {M.empty}  : TypeEnvironment
                typeSignaturesCollect USE {M.union} {M.empty} : {M.Map Name (TyVar, PolyType)}
                typeErrors USE {(++)} {[]} : TypeErrors
                substitutionCollect USE {(++)} {[]} : {[(TyVar, MonoType)]}
                tlEnvironment USE {M.union} {M.empty} : {M.Map Name TyVar}
                resolvedContraints USE {(++)} {[]} : {[Constraint]}
        ]

ATTR MaybeDeclarations Qualifier Qualifiers
        [ 
                typeSignatures : {M.Map Name (TyVar, PolyType)}
                substitution : {[(TyVar, MonoType)]}
                importEnvironment : ImportEnvironment
                axioms : {[Axiom]}
            |   betaUnique : Integer
            |   environment USE {M.union} {M.empty} : {M.Map Name TyVar}
                bindingGroups USE {(++)} {[]} : {[BindingGroup]}
                typeSignaturesCollect USE {M.union} {M.empty} : {M.Map Name (TyVar, PolyType)}
                typeErrors USE {(++)} {[]} : TypeErrors
                resolvedContraints USE {(++)} {[]} : {[Constraint]}
        ]

ATTR Body Declaration Declarations MaybeDeclarations FunctionBinding FunctionBindings LeftHandSide RightHandSide Expression Expressions MaybeExpression
        GuardedExpressions GuardedExpression Pattern Patterns Alternative Alternatives
            [   monos:Monos 
            |   
            |
            ]

ATTR Declaration Declarations                   [ inheritedBDG:InheritedBDG | | inheritedBDGCollect : InheritedBDG ]
{

unifyVar :: TyVar -> TyVar -> Constraint
unifyVar v1 v2 = Constraint_Unify (var v1) (var v2)

substitutePoly :: TyVar -> [(TyVar, MonoType)] -> MonoType
substitutePoly v env = case lookup v env of
    Nothing -> error $ "Cannot provide substitution for " ++ show v
    Just m -> m

bindTypeVariables :: [TyVar] -> PolyType -> PolyType
bindTypeVariables = flip (foldr ((PolyType_Bind .) . UL.bind))

type SolveResult = ([TypeError], [Warning], [(TyVar, MonoType)], Constraints)

constructErrors :: (Either NamedSolverError Solution, Graph) -> SolveResult
constructErrors (et, _) = either (\e -> (makeTypeError e, [], [], [])) (\solution -> ([], [], substitution solution, residual solution)) et

getTypeErrors :: SolveResult -> [TypeError]
getTypeErrors (te, _, _, _) = te

getWarnings :: SolveResult -> [Warning]
getWarnings (_, wa, _, _) = wa

getSubstitution :: SolveResult -> [(TyVar, MonoType)]
getSubstitution (_, _, subs, _) = subs

getResidualConstraints :: SolveResult -> [Constraint]
getResidualConstraints (_, _, _, cs) = cs

lookupType :: M.Map Name (TyVar, PolyType) -> Name -> TyVar -> TpScheme
lookupType env name _ = 
    case M.lookup name env of
        Nothing -> internalError "TypeInferenceRules" "lookupType" "Top level type not found"
        Just (_, p) -> polyTypeToTypeScheme p
}

SEM Module
    | Module
        lhs . dictionaryEnvironment = emptyDictionaryEnvironment
        lhs . toplevelTypes = trace "Residual constraints" $ traceShow (getResidualConstraints @solveResults) $ trace (unlines $ map show $ sortOn fst $ nub $ getSubstitution @solveResults) $ if null @typeErrors then M.mapWithKey (lookupType @body.typeSignaturesCollect) @body.tlEnvironment else M.empty -- 
        loc . typeErrors = concatMap makeMissingInstanceError (getResidualConstraints @solveResults \\ @body.resolvedContraints) ++ getTypeErrors @solveResults ++ @body.typeErrors
        lhs . warnings = getWarnings @solveResults
        loc . axioms = classEnvironmentToAxioms (classEnvironment @lhs.importEnvironment)
        body . axioms = @axioms
        body . betaUnique = 1
        body . substitution = (if null @body.assumptions then id else trace "Unresolved assumptions" . traceShow @body.assumptions)getSubstitution @solveResults
        body . monos = []
        loc . constrs = @body.constraints ++  map (uncurry (Constraint_Unify . var)) @body.substitutionCollect
        loc . tyvars = @body.touchables
        loc . solveResults = constructErrors $ runFreshM $ solve @axioms [] (@constrs) @tyvars
        body . typeSignatures = M.map (\tps -> (integer2Name (-1), tpSchemeToPolyType tps)) $ typeEnvironment @lhs.importEnvironment

SEM Body
    | Body
        declarations . bindingGroups    = []
        -- lhs . toplevelTypes = M.map (monoTypeToTypeScheme.getMonoFromPoly.snd) @lhs.typeSignatures `M.union` M.map (monoTypeToTypeScheme.getMonoFromPoly.snd) @typeSignatures
        declarations . betaUnique = @lhs.betaUnique
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            lhs . constraints,
            lhs . betaUnique,
            lhs . substitutionCollect,
            lhs . typeErrors,
            lhs . resolvedContraints,
            loc . iBDG
        ) =
            let inputBDG = (True, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` @lhs.typeSignatures, [], @declarations.touchables, Nothing, @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
            in  bindingGroupAnalysis inputBDG @declarations.bindingGroups

ATTR FunctionBinding FunctionBindings [ betasLeft : {[TyVar]} betaRight : TyVar | | name : Name numberOfPatterns : Integer  ]

SEM Declaration
    | FunctionBindings
        lhs . betaUnique        = @bindings.betaUnique
        lhs . bindingGroups     = [@bindingGroup]
        lhs . substitutionCollect = []
        loc . bindingGroup      = (@environment, @assumptions, @constraints, @bindings.substitutionCollect)
        -- lhs . toplevelTypes  = M.singleton (@bindings.name) (maybe @err polyTypeToTypeScheme $ lookup @beta @lhs.substitution)
        lhs . tlEnvironment     = @environment
        loc . environment       = M.singleton @bindings.name @beta
        loc . assumptions       = @bindings.assumptions
        lhs . touchables        = @beta : @br : @bls ++ @bindings.touchables
        loc . constraints       = @parameterCons ++ @bindings.constraints 
        loc . bls               = take (fromInteger @bindings.numberOfPatterns) (map integer2Name [(@lhs.betaUnique + 2)..])
        loc . br                = integer2Name $ @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . parameterCons     = [Constraint_Unify (var @beta) (foldr ((:-->:) . var) (var @br) @bls)]
                    
        loc . err               = internalError "TypeInferenceRules.ag" "FunctionBindings" ("No substitution found for " ++ show @bindings.name)
        bindings.betasLeft      = @bls 
        bindings.betaRight      = @br 
        bindings . betaUnique   = @lhs.betaUnique + 2 + @bindings.numberOfPatterns
        bindings . monos        = M.elems (@bindings.environment M.\\ @lhs.typeSignatures) ++ @lhs.monos
    | PatternBinding
        lhs . tlEnvironment     = @environment
        lhs . bindingGroups     = [@bindingGroup]
        lhs . substitutionCollect = []
        loc . bindingGroup      = (@environment, @assumptions, @constraints, @righthandside.substitutionCollect)
        --lhs . toplevelTypes     = M.fromList $ map (\(n, v) -> (n, monoTypeToTypeScheme $ substitutePoly v @lhs.substitution)) $ M.toList @pattern.environment
        lhs . touchables        = @betaRight : @pattern.touchables ++ @righthandside.touchables
        loc . constraints       = [unifyVar @betaRight @pattern.beta, unifyVar @betaRight @righthandside.beta] ++ @pattern.constraints ++ @righthandside.constraints
        loc . environment       = @pattern.environment
        loc . assumptions       = @righthandside.assumptions
        pattern . betaUnique    = @lhs.betaUnique + 1 
        righthandside . monos   = M.elems (@pattern.environment M.\\ @lhs.typeSignatures) ++ @lhs.monos
        loc . betaRight         = integer2Name @lhs.betaUnique
        loc . err               = internalError "TypeInferenceRules.ag" "PatternBinding" "No substitution found for type"
    | TypeSignature
        lhs . touchables        = @beta : map fst (M.elems @ts)
        loc . beta              = integer2Name @lhs.betaUnique
        lhs . betaUnique        = @bu
        lhs . typeSignaturesCollect = @ts
        loc . (ts, bu)          = foldr (\n (m, b) -> let 
                                                (t, b') = typeToPolytype b @type.self
                                                m' = M.insert n (integer2Name b', t) m
                                            in (m', b' + 2)) (M.empty, @lhs.betaUnique + 1) $ @names.self

ATTR Pattern    [ | | beta : TyVar ]
ATTR Patterns   [ | | betas : {[TyVar]} numberOfPatterns:Integer ]


SEM Patterns
  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . numberOfPatterns = 1 + @tl.numberOfPatterns
  | Nil
      lhs . betas            = []
          . numberOfPatterns = 0
SEM Pattern
    | Variable
        lhs . touchables    = [@beta]
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . environment   = M.singleton @name.self @beta
        loc . beta          = integer2Name @lhs.betaUnique
    | Literal
        lhs . touchables    = [@beta]
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType]
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
    | Tuple
        patterns    . betaUnique        = @lhs.betaUnique + 1
        lhs         . constraints       = @constraint : @patterns.constraints
        lhs         . touchables        = @beta : @patterns.touchables
        loc         . beta              = integer2Name @lhs.betaUnique
                    . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @patterns.betas))
    | Wildcard
        lhs         . touchables        = [@beta]
        lhs         . betaUnique        = @lhs.betaUnique + 1
        loc         . beta              = integer2Name @lhs.betaUnique
    | List 
        lhs         . touchables        = @beta : @elemBeta : @patterns.touchables
        lhs         . constraints       = @lstConstraints ++ @patterns.constraints
        patterns    . betaUnique        = @lhs.betaUnique + 2
        loc         . beta              = integer2Name @lhs.betaUnique
        loc         . elemBeta          = integer2Name (@lhs.betaUnique + 1)
        loc         . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) : map (unifyVar @elemBeta) @patterns.betas
    | Constructor
        patterns    . betaUnique        = @lhs.betaUnique + 2
        lhs . touchables                = @beta : @betaCon : @patterns.touchables
        lhs . constraints               = @conApply : @conConstraints ++ @patterns.constraints
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . betaCon                   = integer2Name (@lhs.betaUnique + 1)
        loc . conApply                  = Constraint_Unify (var @betaCon) (foldr (:-->:) (var @beta) (map var @patterns.betas))
        loc . conConstraints            = [Constraint_Inst (var @betaCon) @tp]
        loc . tp                        = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                            Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                            Just ctp -> tpSchemeToPolyType ctp
    | InfixConstructor
        leftPattern . betaUnique        = @lhs.betaUnique + 2
        lhs . touchables                = @beta : @betaCon : @leftPattern.touchables ++ @rightPattern.touchables
        lhs . constraints               = @conApply : @conConstraints ++ @leftPattern.constraints ++ @rightPattern.constraints
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . betaCon                   = integer2Name (@lhs.betaUnique + 1)
        loc . conApply                  = Constraint_Unify (var @betaCon) (var @leftPattern.beta :-->: (var @rightPattern.beta :-->: var @beta))
        loc . tp                        = case M.lookup @constructorOperator.self (valueConstructors @lhs.importEnvironment) of
                                            Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                            Just ctp -> tpSchemeToPolyType ctp
        loc . conConstraints            = [Constraint_Inst (var @betaCon) @tp]
    | As
        pattern . betaUnique            = @lhs.betaUnique + 1
        lhs . touchables                = @beta : @pattern.touchables
        lhs . constraints               = unifyVar @beta @pattern.beta : @pattern.constraints
        lhs . environment               = M.insert @name.self @beta @pattern.environment
        loc . beta                      = integer2Name @lhs.betaUnique

        
SEM FunctionBinding 
    | FunctionBinding
        lhs . constraints       = @locConstraints ++ @lefthandside.constraints ++ @righthandside.constraints
        lhs . name              = @lefthandside.name
        lhs . numberOfPatterns  = @lefthandside.numberOfPatterns
        lhs . assumptions       = @righthandside.assumptions M.\\ @lefthandside.environment
        loc . locConstraints    = Constraint_Unify (var @lhs.betaRight) (var @righthandside.beta) : 
                                    zipWith (\bt bb -> Constraint_Unify (var bt) (var bb)) @lhs.betasLeft @lefthandside.betas ++
                                    (concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Unify (var a') (var e) | (_, a') <- a]) @righthandside.assumptions @lefthandside.environment)
        righthandside . monos   = M.elems @lefthandside.environment ++ @lhs.monos
        

SEM FunctionBindings

  | Cons
        lhs . numberOfPatterns  = @hd.numberOfPatterns
            . name              = @hd.name
  | Nil
        lhs . numberOfPatterns  = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
            . name              = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"


ATTR LeftHandSide   [ | | name : {Name} betas : {[TyVar]} numberOfPatterns:Integer ]

SEM LeftHandSide
    | Function
        lhs . betas             = @patterns.betas
        lhs . numberOfPatterns  = @patterns.numberOfPatterns
        lhs . name              = @name.self
    | Infix
        lhs . betas             = [@leftPattern.beta, @rightPattern.beta]
        lhs . numberOfPatterns  = 2
        lhs . name              = @operator.self
    | Parenthesized
        lhs . betas = @lefthandside.betas ++ @patterns.betas
        lhs . numberOfPatterns = @lefthandside.numberOfPatterns + @patterns.numberOfPatterns

ATTR RightHandSide  [ betaRight : TyVar | | beta : TyVar]

SEM RightHandSide
    | Expression
        lhs     . assumptions = @where.assumptions
                . constraints = @where.constraints
        where   . assumptions = @expression.assumptions
                . constraints = @expression.constraints
    | Guarded
        lhs                 . beta           = @lhs.betaRight
        lhs                 . assumptions    = @where.assumptions
                            . constraints    = @where.constraints
        guardedexpressions  . numberOfGuards = length @guardedexpressions.self
        where               . assumptions    = @guardedexpressions.assumptions
                            . constraints    = @guardedexpressions.constraints

ATTR GuardedExpressions GuardedExpression [ betaRight:TyVar | | beta : TyVar]

SEM GuardedExpression

  | GuardedExpression
      lhs . constraints = [Constraint_Unify (var @guard.beta) (MonoType_Con "Bool" []), (unifyVar @expression.beta @lhs.betaRight)] ++ @guard.constraints ++ @expression.constraints

ATTR MaybeDeclarations [ | touchables : Touchables assumptions:Assumptions constraints:Constraints substitutionCollect : Substitution | ]

SEM MaybeDeclarations
    | Just
        lhs . touchables        = @touchables
        lhs . constraints       = @constraints
        lhs . bindingGroups     = []
        loc . inheritedBDG      = []
        (
            loc . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            loc . constraints,
            lhs . betaUnique,
            lhs . substitutionCollect,
            lhs . typeErrors,
            lhs . resolvedContraints,
            loc . iBDG
        ) =
            let inputBDG = (False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` @lhs.typeSignatures, @lhs.monos, @declarations.touchables ++ @lhs.touchables, Just (@lhs.assumptions, @lhs.constraints, @lhs.substitutionCollect), @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups



ATTR Expression MaybeExpression [ | | beta : TyVar]
ATTR Expressions [ | | betas : {[TyVar]} nrOfExpressions : Integer]

SEM Expressions
    | Cons
        lhs . betas = @hd.beta : @tl.betas
        lhs . nrOfExpressions = @tl.nrOfExpressions + 1
    | Nil 
        lhs . betas = []
        lhs . nrOfExpressions = 0


SEM Expression
    | Literal
        lhs . betaUnique    = @lhs.betaUnique + 1
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType]
        lhs . touchables    = [@beta]
    | Variable
        lhs . touchables    = [@beta]
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . assumptions   = M.singleton @name.self [(@name.self, @beta)]
    | NormalApplication
        loc . beta              = integer2Name @lhs.betaUnique
        function . betaUnique   = @lhs.betaUnique + 1
        lhs . touchables        = @beta : @function.touchables ++ @arguments.touchables
        lhs . constraints       = [@constraint] ++ @function.constraints ++ @arguments.constraints
        loc . constraint        = Constraint_Unify (var @function.beta) (foldr (:-->:) (var @beta) (map var @arguments.betas))
    | If
        lhs . constraints       = @constraints ++ concat [@guardExpression.constraints, @thenExpression.constraints, @elseExpression.constraints]
        lhs . touchables        = @beta : concat [ @guardExpression.touchables, @thenExpression.touchables, @elseExpression.touchables ]
        guardExpression.betaUnique = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . constraints       =   [
                                        Constraint_Unify (var @guardExpression.beta) (MonoType_Con "Bool" []),
                                        unifyVar @beta @thenExpression.beta,
                                        unifyVar @beta @elseExpression.beta 
                                    ]
    | Lambda
        lhs . touchables        = @beta : @expression.touchables ++ @patterns.touchables
        lhs . constraints       = @fConstraint : @envConstraints ++ @expression.constraints ++ @patterns.constraints
        lhs . assumptions       = @expression.assumptions M.\\ @patterns.environment
        loc . envConstraints    = concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Unify (var a') (var e) | (_, a') <- a]) @expression.assumptions @patterns.environment
        patterns . betaUnique   = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . fConstraint       = Constraint_Unify (foldr ((:-->:).var) (var @expression.beta) @patterns.betas) (var @beta)
        expression . monos       = M.elems @patterns.environment ++ getMonos @envConstraints ++ @lhs.monos
    | Tuple
        lhs . touchables        = @beta : @expressions.touchables
        lhs . constraints       = @constraint : @expressions.constraints
        loc . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @expressions.betas))
        loc . beta              = integer2Name @lhs.betaUnique
        expressions . betaUnique = @lhs.betaUnique + 1
    | List
        lhs . touchables        = @elemBeta : @beta : @expressions.touchables
        lhs . constraints       = @lstConstraints ++ @expressions.constraints
        expressions . betaUnique = @lhs.betaUnique + 2
        loc . elemBeta          = integer2Name @lhs.betaUnique
        loc . beta              = integer2Name (@lhs.betaUnique + 1)
        loc . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) : map (unifyVar @elemBeta) @expressions.betas
    | Constructor
        lhs . touchables        = @beta : [] -- getTypeVariablesFromMonoType @tp
        lhs . betaUnique        = @lhs.betaUnique + 1
        loc . tp                = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                    Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                    Just ctp -> tpSchemeToPolyType ctp
        lhs . constraints       = [Constraint_Inst (var @beta) @tp]
        loc . beta              = integer2Name @lhs.betaUnique
    | InfixApplication
        leftExpression . betaUnique = @lhs.betaUnique + 2
        lhs . touchables            = @beta : @betaResOp : @leftExpression.touchables ++ @operator.touchables ++ @rightExpression.touchables
        lhs . constraints           = @constraints ++ @leftExpression.constraints ++ @operator.constraints ++ @rightExpression.constraints
        loc . beta                  = integer2Name @lhs.betaUnique
        loc . betaResOp             = integer2Name $ @lhs.betaUnique + 1 
    	loc . conOperator           = Constraint_Unify (var @operator.beta) (var @leftExpression.beta :-->: (var @rightExpression.beta :-->: var @betaResOp))
        loc . constraints           = case (@leftExpression.section,@rightExpression.section) of
                                                (False,False) -> [ @conOperator, (unifyVar @betaResOp @beta)                        ]
                                                (True ,True ) -> [               (unifyVar @operator.beta @beta)                        ]
                                                (False,True ) -> [ @conOperator, (Constraint_Unify (var @rightExpression.beta :-->: var @betaResOp) (var @beta)) ]
                                                (True ,False) -> [ @conOperator, (Constraint_Unify (var @leftExpression.beta  :-->: var @betaResOp) (var @beta)) ]
    | Let
        declarations.betaUnique = @lhs.betaUnique + 1
        lhs . touchables        = @beta : @touchables
        lhs . constraints       = unifyVar @beta @expression.beta : @constraints
        lhs . bindingGroups     = []
        loc . inheritedBDG      = []
        loc . beta              = integer2Name @lhs.betaUnique
        (
            loc . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            loc . constraints,
            lhs . betaUnique,
            lhs . substitutionCollect,
            lhs . typeErrors,
            lhs . resolvedContraints,
            loc . iBDG
        ) =
            let inputBDG = (False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` @lhs.typeSignatures, @lhs.monos, @declarations.touchables ++ @expression.touchables, Just (@expression.assumptions, @expression.constraints, @expression.substitutionCollect),  @declarations.typeErrors ++ @expression.typeErrors, @declarations.resolvedContraints ++ @expression.resolvedContraints ,@expression.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups
    | Case
        lhs . touchables              = @beta : @beta' : @expression.touchables ++ @alternatives.touchables
        lhs . constraints             = unifyVar @expression.beta @beta' : @expression.constraints ++ @alternatives.constraints
        expression      . betaUnique  = @lhs.betaUnique + 2
        alternatives    . betaLeft    = @beta'
                        . betaRight   = @beta
        loc             . beta        = integer2Name @lhs.betaUnique
                        . beta'       = integer2Name $ @lhs.betaUnique + 1
    | Typed 
        expression . betaUnique = @bu
        lhs . touchables    = @beta : @expression.touchables
        lhs . constraints   =   [
                                    unifyVar @beta @expression.beta,
                                    Constraint_Inst (var @beta) @tp
                                ] ++ @expression.constraints
        loc . beta          = integer2Name @lhs.betaUnique
        loc . (tp, bu)      = typeToPolytype (@lhs.betaUnique + 1) @type.self
    | Comprehension
        lhs . constraints           = @newcon : @qualifiers.constraints
        lhs . touchables            = @beta : @expression.touchables ++ @qualifiers.touchables
        expression  . betaUnique    = @lhs.betaUnique + 1
        qualifiers  . assumptions   = @expression.assumptions
                    . constraints   = @expression.constraints
                    . monos         = []
        loc         . assumptions   = @qualifiers.assumptions
                    . beta          = integer2Name @lhs.betaUnique
                    . newcon        = Constraint_Unify (monotypeList (var @expression.beta)) (var @beta)

ATTR Alternative Alternatives [ betaLeft:TyVar betaRight:TyVar | | ]

SEM Alternative
    | Alternative
        lhs . constraints = unifyVar @pattern.beta @lhs.betaLeft : @envConstraints ++ @pattern.constraints ++ @righthandside.constraints
        lhs . assumptions =  @righthandside.assumptions M.\\ @pattern.environment
        loc . envConstraints = concat $ M.elems (M.intersectionWith (\a' e -> [unifyVar a e | (_, a) <- a']) @righthandside.assumptions @pattern.environment)

ATTR Qualifier Qualifiers [ |  touchables : {[TyVar]} assumptions:Assumptions constraints:Constraints substitutionCollect : Substitution monos : Monos| ]

SEM Qualifier
    | Guard
        lhs . touchables = @guard.touchables ++ @lhs.touchables
        lhs . assumptions = @lhs.assumptions `combineAssumptions` @guard.assumptions
        lhs . constraints =  Constraint_Unify (var @guard.beta) (MonoType_Con "Bool" []) : @guard.constraints ++ @lhs.constraints
        lhs . substitutionCollect = @lhs.substitutionCollect ++ @guard.substitutionCollect
    | Generator
        lhs . touchables        = @expression.touchables ++ @pattern.touchables ++ @lhs.touchables
        lhs . assumptions       = @assumptions' `combineAssumptions` @expression.assumptions
        lhs . constraints       = @newcon : @envConstraints ++ @pattern.constraints ++ @expression.constraints ++ @lhs.constraints
        lhs . substitutionCollect = @lhs.substitutionCollect ++ @expression.substitutionCollect
        loc . newcon            = Constraint_Unify (var @expression.beta) $ monotypeList (var @pattern.beta)
        loc . assumptions'      = @lhs.assumptions M.\\ @pattern.environment
        loc . envConstraints    = concat $ M.elems (M.intersectionWith (\a' e -> [unifyVar a e | (_, a) <- a']) @lhs.assumptions @pattern.environment)
        lhs . monos = @lhs.monos
    | Let
        lhs . bindingGroups     = []
        loc . inheritedBDG      = []
        declarations.monos = @lhs.monos
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            lhs . constraints,
            lhs . betaUnique,
            lhs . substitutionCollect,
            lhs . typeErrors,
            lhs . resolvedContraints,
            loc . iBDG
        ) =
            let inputBDG = (False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` @lhs.typeSignatures, @lhs.monos, @declarations.touchables ++ @lhs.touchables, Just (@lhs.assumptions, @lhs.constraints, @lhs.substitutionCollect), @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups

SEM Qualifiers

  | Cons
        lhs . assumptions = @hd.assumptions
            . constraints = @hd.constraints
            . touchables  = @hd.touchables
            . betaUnique = @hd.betaUnique
            . monos     = @hd.monos
        hd  . assumptions = @tl.assumptions
            . constraints = @tl.constraints
            . touchables  = @tl.touchables
            . betaUnique = @tl.betaUnique
            . monos = @tl.monos
        tl  . assumptions = @lhs.assumptions
            . constraints = @lhs.constraints
            . touchables = @lhs.touchables
            . betaUnique = @lhs.betaUnique
            . monos = @lhs.monos



ATTR MaybeExpression [ | | section : Bool]          

SEM MaybeExpression

  | Just
      lhs . section = False

  | Nothing
      lhs . touchables  = [@beta]
      lhs . section     = True
          . betaUnique  = @lhs.betaUnique + 1
      loc . beta        = integer2Name @lhs.betaUnique
      


ATTR Literal [ | | literalType : MonoType]

SEM Literal
    | Int
        lhs . literalType   = MonoType_Con "Int" []
    | Float
        lhs . literalType   = MonoType_Con "Float" []
    | String
        lhs . literalType   = MonoType_Con "String" []
    | Char
        lhs . literalType   = MonoType_Con "Char" []
              
{

}

