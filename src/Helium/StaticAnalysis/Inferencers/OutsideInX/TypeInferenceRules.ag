
ATTR Module Body Declaration Declarations Expression Expressions
     GuardedExpression GuardedExpressions
     MaybeExpression RecordExpressionBinding
     RightHandSide Alternative Alternatives FunctionBinding
     FunctionBindings Statement RecordExpressionBindings
     Statements AnnotatedType Types Constructor AnnotatedTypes 
     ContextItem FieldDeclaration Constructors ContextItems 
     FieldDeclarations Type Literal LeftHandSide RightHandSide
     Pattern Patterns
        [ 
                typeSignatures : {M.Map Name (TyVar, PolyType)}
                substitution : {[(TyVar, MonoType)]}
                importEnvironment : ImportEnvironment
                axioms : {[Axiom]}
                classContexts : {[(String, [String], [TyVar])]}
                instanceType : {Maybe (Name, [(String, TyVar)])}
            |   betaUnique : Integer
            |   assumptions USE {M.unionWith (++)} {M.empty} : {M.Map Name [(Name, TyVar)]}
                environment USE {M.union} {M.empty} : {M.Map Name TyVar}
                constraints USE {(++)} {[]} : {[Constraint]}
                bindingGroups USE {(++)} {[]} : {[BindingGroup]}
                touchables USE {(++)} {[]} : {[TyVar]}
                toplevelTypes USE {M.union} {M.empty}  : TypeEnvironment
                typeSignaturesCollect USE {M.union} {M.empty} : {M.Map Name (TyVar, PolyType)}
                typeErrors USE {(++)} {[]} : TypeErrors

                tlEnvironment USE {M.union} {M.empty} : {M.Map Name TyVar}
                resolvedContraints USE {(++)} {[]} : {[Constraint]}
                gadtConstraints USE {(++)} {[]} : GADTConstraints
        ]

ATTR MaybeDeclarations Qualifier Qualifiers
        [ 
                typeSignatures : {M.Map Name (TyVar, PolyType)}
                substitution : {[(TyVar, MonoType)]}
                importEnvironment : ImportEnvironment
                axioms : {[Axiom]}
                classContexts : {[(String, [String], [TyVar])]}
                instanceType : {Maybe (Name, [(String, TyVar)])}
            |   betaUnique : Integer
            |   environment USE {M.union} {M.empty} : {M.Map Name TyVar}
                bindingGroups USE {(++)} {[]} : {[BindingGroup]}
                typeSignaturesCollect USE {M.union} {M.empty} : {M.Map Name (TyVar, PolyType)}
                typeErrors USE {(++)} {[]} : TypeErrors
                resolvedContraints USE {(++)} {[]} : {[Constraint]}
        ]

ATTR Body [  | |               substitutionCollect : {[(TyVar, MonoType)]}]

{

unifyVar :: TyVar -> TyVar -> Constraint
unifyVar v1 v2 = Constraint_Unify (var v1) (var v2)

substitutePoly :: TyVar -> [(TyVar, MonoType)] -> MonoType
substitutePoly v env = case lookup v env of
    Nothing -> error $ "Cannot provide substitution for " ++ show v
    Just m -> m

bindTypeVariables :: [TyVar] -> PolyType -> PolyType
bindTypeVariables = flip (foldr ((PolyType_Bind .) . UL.bind))

type SolveResult = ([TypeError], [Warning], [(TyVar, MonoType)], Constraints)

constructErrors :: (Either NamedSolverError Solution, Graph) -> SolveResult
constructErrors (et, _) = either (\e -> (createTypeError e, [], [], [])) (\solution -> ([], [], substitution solution, residual solution)) et

getTypeErrors :: SolveResult -> [TypeError]
getTypeErrors (te, _, _, _) = te

getWarnings :: SolveResult -> [Warning]
getWarnings (_, wa, _, _) = wa

getSubstitution :: SolveResult -> [(TyVar, MonoType)]
getSubstitution (_, _, subs, _) = subs

getResidualConstraints :: SolveResult -> [Constraint]
getResidualConstraints (_, _, _, cs) = cs

lookupType :: M.Map Name (TyVar, PolyType) -> Name -> TyVar -> TpScheme
lookupType env name _ = 
    case M.lookup name env of
        Nothing -> internalError "TypeInferenceRules" "lookupType" "Top level type not found"
        Just (_, p) -> polyTypeToTypeScheme p
}

SEM Module
    | Module
        lhs . dictionaryEnvironment = emptyDictionaryEnvironment
        lhs . toplevelTypes = const id (trace "Residual constraints" $ traceShow (getResidualConstraints @solveResults)) $ if null @typeErrors then M.mapWithKey (lookupType @body.typeSignaturesCollect) @body.tlEnvironment else M.empty -- 
        loc . typeErrors = traceShowId $ const id (trace (unlines $ map show $ sortOn fst $ nub $ @substitution)) $ concatMap (makeTypeError @tyvars)(getResidualConstraints @solveResults \\ @body.resolvedContraints) ++ getTypeErrors @solveResults ++ @body.typeErrors
        lhs . warnings = getWarnings @solveResults
        loc . axioms = typeEnvironmentToAxioms (typeSynonyms @lhs.importEnvironment) ++ classEnvironmentToAxioms (classEnvironment @lhs.importEnvironment)
        body . axioms = @axioms
        body . betaUnique = 1
        loc . substitution = (if null @body.assumptions then id else trace "Unresolved assumptions" . traceShow @body.assumptions) (getSubstitution @solveResults ++ @body.substitutionCollect)
        body . substitution = @substitution
        loc . constrs = @body.constraints
        loc . tyvars = @body.touchables
        loc . solveResults = constructErrors $ contFreshM (solve @axioms (map (uncurry (Constraint_Unify . var)) @body.substitutionCollect) (@constrs) @tyvars) @body.betaUnique 
        body . typeSignatures = M.map (\tps -> (integer2Name (-1), tpSchemeToPolyType tps)) $ typeEnvironment @lhs.importEnvironment
        body . classContexts = []
        body . instanceType = Nothing

SEM Body
    | Body
        declarations . bindingGroups    = []
        lhs . constraints = @loc.constraints
        -- lhs . toplevelTypes = M.map (monoTypeToTypeScheme.getMonoFromPoly.snd) @lhs.typeSignatures `M.union` M.map (monoTypeToTypeScheme.getMonoFromPoly.snd) @typeSignatures
        declarations . betaUnique = @lhs.betaUnique
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            loc . constraints,
            lhs . betaUnique,
            lhs . substitutionCollect,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let !inputBDG = (True, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables, Nothing, @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique, @lhs.classContexts)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups

ATTR FunctionBinding FunctionBindings [ betasLeft : {[TyVar]} betaRight : TyVar | | name : Name numberOfPatterns : Integer  ]


SEM Declaration
    | FunctionBindings
        lhs . betaUnique        = @bindings.betaUnique
        lhs . bindingGroups     = [@bindingGroup]
        loc . bindingGroup      = (@environment, @assumptions, @constraints, @bindings.gadtConstraints)
        -- lhs . toplevelTypes  = M.singleton (@bindings.name) (maybe @err polyTypeToTypeScheme $ lookup @beta @lhs.substitution)
        lhs . tlEnvironment     = @environment
        loc . environment       = M.singleton @bindings.name @beta
        loc . assumptions       = @bindings.assumptions
        lhs . touchables        = maybe [] (map snd . snd) @lhs.instanceType  ++ @beta : @br : @bls ++ @bindings.touchables
        loc . constraints       = @instanceCons ++ @parameterCons ++ @bindings.constraints 
        loc . bls               = take (fromInteger @bindings.numberOfPatterns) (map integer2Name [(@lhs.betaUnique + 2)..])
        loc . br                = integer2Name $ @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . parameterCons     = [Constraint_Unify (var @beta) (foldr ((:-->:) . var) (var @br) @bls)]
        loc . instanceCons      = case @lhs.instanceType of
                                    Nothing -> []
                                    Just (cn, betas) -> let 
                                            (classTypeVariables, classFunctions) = fromMaybe (internalError "TypeInferenceRules" "n/a" "class not found") $
                                                M.lookup cn (classMemberEnvironment @lhs.importEnvironment)
                                            (_, functionTpScheme, _, _) = fromMaybe (internalError "TypeInferenceRules" "n/a" "class function not found")
                                                (find (\(n, _, _, _) -> n == @bindings.name) classFunctions) 
                                            (polyType, substitution) = tpSchemeToPolyType' (map show classTypeVariables) functionTpScheme
                                            instanceType :: PolyType
                                            instanceType = UL.substs [(snd (head substitution), var $ snd (head betas))] polyType
                                        in [Constraint_Inst (var @beta) instanceType]      
        loc . err               = internalError "TypeInferenceRules.ag" "FunctionBindings" ("No substitution found for " ++ show @bindings.name)
        bindings.betasLeft      = @bls 
        bindings.betaRight      = @br 
        bindings . betaUnique   = @lhs.betaUnique + 2 + @bindings.numberOfPatterns
    | PatternBinding
        lhs . tlEnvironment     = @environment
        lhs . bindingGroups     = [@bindingGroup]
        loc . bindingGroup      = (@environment, @assumptions, @constraints, @righthandside.gadtConstraints)
        --lhs . toplevelTypes     = M.fromList $ map (\(n, v) -> (n, monoTypeToTypeScheme $ substitutePoly v @lhs.substitution)) $ M.toList @pattern.environment
        lhs . touchables        = @betaRight : @pattern.touchables ++ @righthandside.touchables
        loc . constraints       = [unifyVar @pattern.beta @betaRight, unifyVar @betaRight @righthandside.beta] ++ @pattern.constraints ++ @righthandside.constraints
        loc . environment       = @pattern.environment
        loc . assumptions       = @righthandside.assumptions
        pattern . betaUnique    = @lhs.betaUnique + 1 
        loc . betaRight         = integer2Name @lhs.betaUnique
        loc . err               = internalError "TypeInferenceRules.ag" "PatternBinding" "No substitution found for type"
    | TypeSignature
        lhs . touchables        = @beta : map fst (M.elems @ts)
        loc . beta              = integer2Name @lhs.betaUnique
        lhs . betaUnique        = @bu
        lhs . typeSignaturesCollect = @ts
        loc . (ts, bu)          = foldr (\n (m, b) -> let 
                                                (t, b', mapping) = typeToPolytype b @type.self
                                                addClass :: (String, [String], [TyVar]) -> PolyType -> PolyType
                                                addClass (className, variables, tyvars) pt = case lookup (head variables) mapping of 
                                                    Just v -> UL.substs [(v, var $ head tyvars)] $ addConstraint (Constraint_Class className [var v]) pt
                                                    Nothing -> pt
                                                t' = foldr addClass t @lhs.classContexts
                                                m' = M.insert n (integer2Name b', t') m
                                            in (m', b' + 2)) (M.empty, @lhs.betaUnique + 1) $ @names.self
    | Class
        where       . betaUnique    = @lhs.betaUnique + toInteger (length @simpletype.typevariables)
        loc         . classBetas     = zip (map show @simpletype.typevariables) (map integer2Name [@lhs.betaUnique..])
        lhs . touchables = map snd @classBetas
        lhs . typeSignaturesCollect = @where.typeSignaturesCollect
        where . axioms = [Axiom_Class (UL.bind [] ([], show @simpletype.name, map var $ map snd @classBetas))] ++ concatMap (contextToAxiom @classBetas) @context.self ++ @lhs.axioms
        where . classContexts = [(show @simpletype.name, map show @simpletype.typevariables, map snd @classBetas)] ++ map (\(ContextItem_ContextItem _ cn ts) -> (show cn, map (show . makeTpSchemeFromType) ts, map snd @classBetas)) @context.self
    | Instance
        where . touchables = map snd @instanceBetas
        lhs . touchables = @where.touchables
        loc . instanceBetas = zip (map (show . makeTpSchemeFromType) @types.self) $ (map integer2Name [@lhs.betaUnique..] :: [TyVar])
        loc . (tp, bu, mapping) = typeToPolytype (@lhs.betaUnique + toInteger (length @instanceBetas)) (head @types.self)
        where . constraints = [Constraint_Inst (var $ snd $ head @instanceBetas) @tp]
        where . betaUnique = @bu
        where . instanceType = Just (@name.self, @instanceBetas)
        where . axioms = Axiom_Class (UL.bind [] ([], show @name.self, [getMonoFromPoly @tp])) : concatMap (contextToAxiom @mapping) @context.self ++ @lhs.axioms

{
contextToAxiom :: [(String, TyVar)] -> ContextItem -> [Axiom]
contextToAxiom classBetas (ContextItem_ContextItem r n types) = let err = internalError "TypeInferenceRules" "n/a" "unknown type variable"
    in [Axiom_Class (UL.bind [] ([], show n , map (\t -> maybe (err) var $ lookup (show $ makeTpSchemeFromType t) classBetas) types))]
}

ATTR SimpleType [ | | name:Name typevariables:Names ]

SEM SimpleType
  | SimpleType  lhs . name          = @name.self
                    . typevariables = @typevariables.self

ATTR Pattern    [ | | beta : TyVar ]
ATTR Patterns   [ | | betas : {[TyVar]} numberOfPatterns:Integer ]


SEM Patterns
  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . numberOfPatterns = 1 + @tl.numberOfPatterns
          . resultTypes       = @hd.resultTypes ++ @tl.resultTypes
  | Nil
      lhs . betas            = []
          . numberOfPatterns = 0
          . resultTypes      = []
SEM Pattern
    | Variable
        lhs . touchables    = [@beta]
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . environment   = M.singleton @name.self @beta
        loc . beta          = UL.makeName (show @name.self) @lhs.betaUnique
    | Literal
        lhs . touchables    = [@beta]
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType]
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
    | Tuple
        patterns    . betaUnique        = @lhs.betaUnique + 1
        lhs         . constraints       = @constraint : @patterns.constraints
        lhs         . touchables        = @beta : @patterns.touchables
        loc         . beta              = integer2Name @lhs.betaUnique
                    . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @patterns.betas))
    | Wildcard
        lhs         . touchables        = [@beta]
        lhs         . betaUnique        = @lhs.betaUnique + 1
        loc         . beta              = integer2Name @lhs.betaUnique
    | List 
        lhs         . touchables        = @beta : @elemBeta : @patterns.touchables
        lhs         . constraints       = @lstConstraints ++ @patterns.constraints
        patterns    . betaUnique        = @lhs.betaUnique + 2
        loc         . beta              = integer2Name @lhs.betaUnique
        loc         . elemBeta          = integer2Name (@lhs.betaUnique + 1)
        loc         . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) : map (unifyVar @elemBeta) @patterns.betas
    | Constructor
        patterns    . betaUnique        = @bu2
        lhs . touchables                = @beta : @betaCon : (
                                             if @ct == ConstructorRegular then 
                                                []
                                             else
                                                getTypeVariablesFromMonoType @rt
                                            ) ++ getTypeVariablesFromPolyType' @tp ++ @patterns.touchables
        lhs . constraints               =   if @ct == ConstructorRegular then 
                                                @conApply : @conConstraints ++ @patterns.constraints
                                            else
                                                [Constraint_Unify (var @beta) @rt]
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . betaCon                   = integer2Name (@lhs.betaUnique + 1)
        loc . conApply                  = Constraint_Unify (var @betaCon) (foldr (:-->:) (var @beta) (map var @patterns.betas))
        loc . conConstraints            = [Constraint_Inst (var @betaCon) @tp]
        loc . gadtVariables             =   if @ct == ConstructorRegular then 
                                                []
                                            else
                                                @beta : @betaCon : getTypeVariablesFromPolyType' @tp ++ @patterns.touchables
        loc . gadtAssumeConstraints     =   if @ct == ConstructorRegular then 
                                                []
                                            else
                                                @resConstraints ++  @conApply : @conConstraints ++ @patterns.constraints
        loc . ((tp, bu), ct)            = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                            Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                            Just (ctp, ct) -> (freshen (@lhs.betaUnique + 2) $ tpSchemeToPolyType ctp, ct)
        loc . ((rt, resConstraints), bu2) = freshen @bu $ getResultType (getMonoFromPoly @tp)
        lhs . resultTypes               =  [@rt]

    | InfixConstructor
        leftPattern . betaUnique        = @bu
        lhs . touchables                = @beta : @betaCon : @leftPattern.touchables ++ @rightPattern.touchables ++ getTypeVariablesFromPolyType' @tp
        lhs . constraints               = @conApply : @conConstraints ++ @leftPattern.constraints ++ @rightPattern.constraints
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . betaCon                   = integer2Name (@lhs.betaUnique + 1)
        loc . conApply                  = Constraint_Unify (var @betaCon) (var @leftPattern.beta :-->: (var @rightPattern.beta :-->: var @beta))
        loc . (tp, bu)                  = case M.lookup @constructorOperator.self (valueConstructors @lhs.importEnvironment) of
                                            Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                            Just (ctp, _) -> freshen (@lhs.betaUnique + 2) $ tpSchemeToPolyType ctp
        loc . conConstraints            = [Constraint_Inst (var @betaCon) @tp]
    | As
        pattern . betaUnique            = @lhs.betaUnique + 1
        lhs . touchables                = @beta : @pattern.touchables
        lhs . constraints               = unifyVar @beta @pattern.beta : @pattern.constraints
        lhs . environment               = M.insert @name.self @beta @pattern.environment
        loc . beta                      = integer2Name @lhs.betaUnique

{
getResultType :: MonoType -> (MonoType, [Constraint])
getResultType (_ :-->: x) = getResultType x
getResultType (MonoType_Var _) = error "Return type cannot be a variable"
getResultType (MonoType_Con s tp) = (   MonoType_Con s $ take (length tp) [var (integer2Name x) | x <- [0..]],
                                        zipWith (\tp x -> Constraint_Unify (var $ integer2Name x) tp ) tp [0..]
                                    )
}
        
SEM FunctionBinding 
    | FunctionBinding
        lhs . touchables        = @lefthandside.touchables ++ @righthandside.touchables
        lhs . constraints       =   if null @lefthandside.gadtVariables then 
                                       @lefthandside.constraints ++ @righthandside.constraints
                                    else
                                        --traceShowId $ @locConstraints ++ assConstraints ++ [Constraint_Exists (UL.bind (@righthandside.touchables) (trace "LHS" $ traceShowId @lefthandside.constraints, trace "RHS" $ traceShowId $ @righthandside.constraints))]
                                        @lefthandside.constraints ++ @locConstraints
        lhs . gadtConstraints   =   if null @lefthandside.gadtVariables then [] else
                                        [(@righthandside.touchables ++ @lefthandside.gadtVariables , @lefthandside.gadtAssumeConstraints, @righthandside.constraints ++ @assConstraints , @assumptions)]
        lhs . name              = @lefthandside.name
        lhs . numberOfPatterns  = @lefthandside.numberOfPatterns
        loc . assumptions       = @righthandside.assumptions M.\\ @lefthandside.environment
        loc . locConstraints    = 
                                    zipWith (\bt bb -> Constraint_Unify (var bb) (var bt) ) @lhs.betasLeft @lefthandside.betas
        loc. assConstraints     = (concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Inst (var a') (var e) | (_, a') <- a]) 
                                        @righthandside.assumptions @lefthandside.environment) ++ [Constraint_Unify (var @lhs.betaRight) (var @righthandside.beta)]

ATTR FunctionBinding LeftHandSide Pattern Patterns 
    [ 
    | 
    |
        gadtVariables USE {(++)} {[]} : {[TyVar]}
        gadtAssumeConstraints USE {(++)} {[]} : {[Constraint]}
        resultTypes : {[MonoType]}
    ]        

SEM FunctionBindings

  | Cons
        lhs . numberOfPatterns  = @hd.numberOfPatterns
            . name              = @hd.name
  | Nil
        lhs . numberOfPatterns  = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
            . name              = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"


ATTR LeftHandSide   [ | | name : {Name} betas : {[TyVar]} numberOfPatterns:Integer ]

SEM LeftHandSide
    | Function
        lhs . betas             = @patterns.betas
        lhs . numberOfPatterns  = @patterns.numberOfPatterns
        lhs . name              = @name.self
    | Infix
        lhs . betas             = [@leftPattern.beta, @rightPattern.beta]
        lhs . numberOfPatterns  = 2
        lhs . name              = @operator.self
    | Parenthesized
        lhs . betas = @lefthandside.betas ++ @patterns.betas
        lhs . numberOfPatterns = @lefthandside.numberOfPatterns + @patterns.numberOfPatterns

ATTR RightHandSide  [ betaRight : TyVar | | beta : TyVar]

SEM RightHandSide
    | Expression
        lhs     . assumptions = @where.assumptions
                . constraints = unifyVar @lhs.betaRight @expression.beta : @where.constraints
        where   . assumptions = @expression.assumptions
                . constraints = @expression.constraints
    | Guarded
        lhs                 . beta           = @lhs.betaRight
        lhs                 . assumptions    = @where.assumptions
                            . constraints    = @where.constraints
        guardedexpressions  . numberOfGuards = length @guardedexpressions.self
        where               . assumptions    = @guardedexpressions.assumptions
                            . constraints    = @guardedexpressions.constraints

ATTR GuardedExpressions GuardedExpression [ betaRight:TyVar | | beta : TyVar]

SEM GuardedExpression

  | GuardedExpression
      lhs . constraints = [Constraint_Unify (var @guard.beta) (MonoType_Con "Bool" []), (unifyVar @expression.beta @lhs.betaRight)] ++ @guard.constraints ++ @expression.constraints

ATTR MaybeDeclarations [ | touchables : Touchables assumptions:Assumptions constraints:Constraints gadtConstraints : GADTConstraints| ]

SEM MaybeDeclarations
    | Just
        lhs . touchables        = @touchables
        lhs . constraints       = @constraints
        lhs . bindingGroups     = []
        (
            loc . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            loc . constraints,
            lhs . betaUnique,
            _,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let !inputBDG = (False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @lhs.touchables, Just (@lhs.assumptions, @lhs.constraints, @lhs.gadtConstraints), @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique, @lhs.classContexts)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups



ATTR Expression MaybeExpression [ | | beta : TyVar]
ATTR Expressions [ | | betas : {[TyVar]} nrOfExpressions : Integer]

SEM Expressions
    | Cons
        lhs . betas = @hd.beta : @tl.betas
        lhs . nrOfExpressions = @tl.nrOfExpressions + 1
    | Nil 
        lhs . betas = []
        lhs . nrOfExpressions = 0


SEM Expression
    | Literal
        lhs . betaUnique    = @lhs.betaUnique + 1
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType]
        lhs . touchables    = [@beta]
    | Variable
        lhs . touchables    = [@beta]
        loc . beta          = UL.makeName (show @name.self) @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . assumptions   = M.singleton @name.self [(@name.self, @beta)]
    | NormalApplication
        loc . beta              = integer2Name @lhs.betaUnique
        function . betaUnique   = @lhs.betaUnique + 1
        lhs . touchables        = @beta : @function.touchables ++ @arguments.touchables
        lhs . constraints       = [@constraint] ++ @function.constraints ++ @arguments.constraints
        loc . constraint        = Constraint_Unify (var @function.beta) (foldr (:-->:) (var @beta) (map var @arguments.betas))
    | If
        lhs . constraints       = @constraints ++ concat [@guardExpression.constraints, @thenExpression.constraints, @elseExpression.constraints]
        lhs . touchables        = @beta : concat [ @guardExpression.touchables, @thenExpression.touchables, @elseExpression.touchables ]
        guardExpression.betaUnique = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . constraints       =   [
                                        Constraint_Unify (var @guardExpression.beta) (MonoType_Con "Bool" []),
                                        unifyVar @beta @thenExpression.beta,
                                        unifyVar @beta @elseExpression.beta 
                                    ]
    | Lambda
        lhs . touchables        = @beta : @expression.touchables ++ @patterns.touchables
        lhs . constraints       = @fConstraint : @envConstraints ++ @expression.constraints ++ @patterns.constraints
        lhs . assumptions       = @expression.assumptions M.\\ @patterns.environment
        loc . envConstraints    = concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Unify (var a') (var e) | (_, a') <- a]) @expression.assumptions @patterns.environment
        patterns . betaUnique   = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . fConstraint       = Constraint_Unify (foldr ((:-->:).var) (var @expression.beta) @patterns.betas) (var @beta)
    | Tuple
        lhs . touchables        = @beta : @expressions.touchables
        lhs . constraints       = @constraint : @expressions.constraints
        loc . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @expressions.betas))
        loc . beta              = integer2Name @lhs.betaUnique
        expressions . betaUnique = @lhs.betaUnique + 1
    | List
        lhs . touchables        = @elemBeta : @beta : @expressions.touchables
        lhs . constraints       = @lstConstraints ++ @expressions.constraints
        expressions . betaUnique = @lhs.betaUnique + 2
        loc . elemBeta          = integer2Name @lhs.betaUnique
        loc . beta              = integer2Name (@lhs.betaUnique + 1)
        loc . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) : map (unifyVar @elemBeta) @expressions.betas
    | Constructor
        lhs . touchables        = @beta : [] -- getTypeVariablesFromMonoType @tp
        lhs . betaUnique        = @bu
        loc . (tp, bu)          = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                    Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                    Just (ctp, _) -> freshen (@lhs.betaUnique + 1) $ tpSchemeToPolyType ctp
        lhs . constraints       = [Constraint_Inst (var @beta) @tp]
        loc . beta              = integer2Name @lhs.betaUnique
    | InfixApplication
        leftExpression . betaUnique = @lhs.betaUnique + 2
        lhs . touchables            = @beta : @betaResOp : @leftExpression.touchables ++ @operator.touchables ++ @rightExpression.touchables
        lhs . constraints           = @constraints ++ @leftExpression.constraints ++ @operator.constraints ++ @rightExpression.constraints
        loc . beta                  = integer2Name @lhs.betaUnique
        loc . betaResOp             = integer2Name $ @lhs.betaUnique + 1 
    	loc . conOperator           = Constraint_Unify (var @operator.beta) (var @leftExpression.beta :-->: (var @rightExpression.beta :-->: var @betaResOp))
        loc . constraints           = case (@leftExpression.section,@rightExpression.section) of
                                                (False,False) -> [ @conOperator, (unifyVar @betaResOp @beta)                        ]
                                                (True ,True ) -> [               (unifyVar @operator.beta @beta)                        ]
                                                (False,True ) -> [ @conOperator, (Constraint_Unify (var @rightExpression.beta :-->: var @betaResOp) (var @beta)) ]
                                                (True ,False) -> [ @conOperator, (Constraint_Unify (var @leftExpression.beta  :-->: var @betaResOp) (var @beta)) ]
    | Let
        declarations.betaUnique = @lhs.betaUnique + 1
        lhs . touchables        = @beta : @touchables
        lhs . constraints       = unifyVar @beta @expression.beta : @constraints
        lhs . bindingGroups     = []
        loc . beta              = integer2Name @lhs.betaUnique
        (
            loc . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            loc . constraints,
            lhs . betaUnique,
            _,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let !inputBDG = (False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @expression.touchables, Just (@expression.assumptions, @expression.constraints, @expression.gadtConstraints),  @declarations.typeErrors ++ @expression.typeErrors, @declarations.resolvedContraints ++ @expression.resolvedContraints ,@expression.betaUnique, @lhs.classContexts)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups
    | Case
        lhs . touchables              = @beta : @beta' : @expression.touchables ++ @alternatives.touchables
        lhs . constraints             = unifyVar @expression.beta @beta' : @expression.constraints ++ @alternatives.constraints
        expression      . betaUnique  = @lhs.betaUnique + 2
        alternatives    . betaLeft    = @beta'
                        . betaRight   = @beta
        loc             . beta        = integer2Name @lhs.betaUnique
                        . beta'       = integer2Name $ @lhs.betaUnique + 1
    | Typed 
        expression . betaUnique = @bu
        lhs . touchables    = @beta : @expression.touchables
        lhs . constraints   =   [
                                    unifyVar @beta @expression.beta,
                                    Constraint_Inst (var @beta) @tp
                                ] ++ @expression.constraints
        loc . beta          = integer2Name @lhs.betaUnique
        loc . (tp, bu, mapping)      = typeToPolytype (@lhs.betaUnique + 1) @type.self
    | Comprehension
        lhs . constraints           = @newcon : @qualifiers.constraints
        lhs . touchables            = @beta : @expression.touchables ++ @qualifiers.touchables
        expression  . betaUnique    = @lhs.betaUnique + 1
        qualifiers  . assumptions   = @expression.assumptions
                    . constraints   = @expression.constraints
        loc         . assumptions   = @qualifiers.assumptions
                    . beta          = integer2Name @lhs.betaUnique
                    . newcon        = Constraint_Unify (monotypeList (var @expression.beta)) (var @beta)

ATTR Alternative Alternatives [ betaLeft:TyVar betaRight:TyVar | | ]

SEM Alternative
    | Alternative
        lhs . constraints = unifyVar @pattern.beta @lhs.betaLeft : @envConstraints ++ @pattern.constraints ++ @righthandside.constraints
        lhs . assumptions =  @righthandside.assumptions M.\\ @pattern.environment
        loc . envConstraints = concat $ M.elems (M.intersectionWith (\a' e -> [unifyVar a e | (_, a) <- a']) @righthandside.assumptions @pattern.environment)

ATTR Qualifier Qualifiers [ |  touchables : {[TyVar]} assumptions:Assumptions constraints:Constraints substitutionCollect : Substitution gadtConstraints : GADTConstraints | ]

SEM Qualifier
    | Guard
        lhs . touchables = @guard.touchables ++ @lhs.touchables
        lhs . assumptions = @lhs.assumptions `combineAssumptions` @guard.assumptions
        lhs . constraints =  Constraint_Unify (var @guard.beta) (MonoType_Con "Bool" []) : @guard.constraints ++ @lhs.constraints
    | Generator
        lhs . touchables        = @expression.touchables ++ @pattern.touchables ++ @lhs.touchables
        lhs . assumptions       = @assumptions' `combineAssumptions` @expression.assumptions
        lhs . constraints       = @newcon : @envConstraints ++ @pattern.constraints ++ @expression.constraints ++ @lhs.constraints
        loc . newcon            = Constraint_Unify (var @expression.beta) $ monotypeList (var @pattern.beta)
        loc . assumptions'      = @lhs.assumptions M.\\ @pattern.environment
        loc . envConstraints    = concat $ M.elems (M.intersectionWith (\a' e -> [unifyVar a e | (_, a) <- a']) @lhs.assumptions @pattern.environment)
    | Let
        lhs . bindingGroups     = []
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            lhs . constraints,
            lhs . betaUnique,
            _,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let !inputBDG = (False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @lhs.touchables, Just (@lhs.assumptions, @lhs.constraints, @lhs.gadtConstraints), @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique, @lhs.classContexts)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups

SEM Qualifiers

  | Cons
        lhs . assumptions = @hd.assumptions
            . constraints = @hd.constraints
            . touchables  = @hd.touchables
            . betaUnique = @hd.betaUnique
        hd  . assumptions = @tl.assumptions
            . constraints = @tl.constraints
            . touchables  = @tl.touchables
            . betaUnique = @tl.betaUnique
        tl  . assumptions = @lhs.assumptions
            . constraints = @lhs.constraints
            . touchables = @lhs.touchables
            . betaUnique = @lhs.betaUnique



ATTR MaybeExpression [ | | section : Bool]          

SEM MaybeExpression

  | Just
      lhs . section = False

  | Nothing
      lhs . touchables  = [@beta]
      lhs . section     = True
          . betaUnique  = @lhs.betaUnique + 1
      loc . beta        = integer2Name @lhs.betaUnique
      


ATTR Literal [ | | literalType : MonoType]

SEM Literal
    | Int
        lhs . literalType   = MonoType_Con "Int" []
    | Float
        lhs . literalType   = MonoType_Con "Float" []
    | String
        lhs . literalType   = MonoType_Con "String" []
    | Char
        lhs . literalType   = MonoType_Con "Char" []
              
{

}

