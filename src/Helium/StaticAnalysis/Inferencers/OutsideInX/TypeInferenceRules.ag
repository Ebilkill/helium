
ATTR Module Body Declaration Declarations Expression Expressions
     GuardedExpression GuardedExpressions MaybeDeclarations
     MaybeExpression Qualifier Qualifiers RecordExpressionBinding
     RightHandSide Alternative Alternatives FunctionBinding
     FunctionBindings Statement RecordExpressionBindings
     Statements AnnotatedType Types Constructor AnnotatedTypes 
     ContextItem FieldDeclaration Constructors ContextItems 
     FieldDeclarations Type Literal LeftHandSide RightHandSide
     Pattern Patterns
        [ 
                typeSignatures : {M.Map Name (TyVar, PolyType)}
                substitution : {[(TyVar, MonoType)]}
                importEnvironment : ImportEnvironment
                monos : Monos
            |   betaUnique : Integer
            |   assumptions USE {M.unionWith (++)} {M.empty} : {M.Map Name [(Name, TyVar)]}
                environment USE {M.union} {M.empty} : {M.Map Name TyVar}
                constraints USE {(++)} {[]} : {[Constraint]}
                bindingGroups USE {(++)} {[]} : {[BindingGroup]}
                touchables USE {(++)} {[]} : {[(Maybe Name, TyVar)]}
                toplevelTypes USE {M.union} {M.empty}  : TypeEnvironment
                typeSignaturesCollect USE {M.union} {M.empty} : {M.Map Name (TyVar, PolyType)}
                typeErrors USE {(++)} {[]} : TypeErrors
                substitutionCollect USE {(++)} {[]} : {[(TyVar, MonoType)]}
        ]
{
{-
environmentAssumptionsConstraint :: [(Name, PolyType)] -> [(Name, TyVar)] -> ([Constraint], [(Name, TyVar)])
environmentAssumptionsConstraint environment assumptions = 
        let
            (origEnv, otherEnv) = partition (\(_, _, origin) -> origin == Signature) environment
            origEnvNames        = map (\(n, _, _) -> n) origEnv
            otherEnvNames       = map (\(n, _, _) -> n) otherEnv 
            neededAss           :: [((Name, TyVar), [(Name, PolyType)])]
            neededAss           = map fromJust $ filter isJust $ map (\a@(n, _) -> if n `elem` origEnvNames then Just (a, origEnv) else if n `elem` otherEnvNames then Just (a, otherEnv) else Nothing) assumptions
            constructConstraint :: ((Name, TyVar), [(Name, PolyType)]) -> Constraint
            constructConstraint ((n, tv), ass) = case find (\(n', _) -> n == n') ass of
                Nothing -> error "Assumption not found, should not happend"
                Just (_, pt) -> Constraint_Inst (var tv) pt 
            removeAssumptions = map (fst . fst) neededAss
            origConstraints     = map constructConstraint neededAss
        in (origConstraints, filter (\(n, _) -> n `notElem` removeAssumptions) assumptions)  
-}
cleanEnv :: [(Name, TyVar)] -> [(Name, PolyType)] -> [(Name, TyVar)]
cleanEnv orig removes = filter (\x -> fst x `notElem` map fst removes) orig

unifyVar :: TyVar -> TyVar -> Constraint
unifyVar v1 v2 = Constraint_Unify (var v1) (var v2)

substitutePoly :: TyVar -> [(TyVar, MonoType)] -> MonoType
substitutePoly v env = case lookup v env of
    Nothing -> error $ "Cannot provide substitution for " ++ show v
    Just m -> m

bindTypeVariables :: [TyVar] -> PolyType -> PolyType
bindTypeVariables = flip (foldr ((PolyType_Bind .) . UL.bind))

type SolveResult = ([TypeError], [Warning], [(TyVar, MonoType)])

constructErrors :: (Either NamedSolverError Solution, Graph) -> SolveResult
constructErrors (et, _) = either (\e -> ([TypeError [] [] [] []], [], [])) (\solution -> ([], [], substitution solution)) et

getTypeErrors :: SolveResult -> [TypeError]
getTypeErrors (te, _, _) = te

getWarnings :: SolveResult -> [Warning]
getWarnings (_, wa, _) = wa


}

SEM Module
    | Module
        lhs . dictionaryEnvironment = trace ((\(_, _, subs) -> unlines $ map show subs) @solveResults) emptyDictionaryEnvironment
        lhs . toplevelTypes = if null @typeErrors then @body.toplevelTypes else traceShow "Has typeerrors" M.empty -- 
        loc . typeErrors = getTypeErrors @solveResults ++ @body.typeErrors
        lhs . warnings = getWarnings @solveResults
        body . betaUnique = 1
        body . substitution = cleanSubs $ @body.substitutionCollect ++ (\(_, _, subs) -> subs) @solveResults
        body . typeSignatures = @body.typeSignaturesCollect
        loc . constrs = @body.constraints
        loc . tyvars = trace "Touchables " $ trace (unlines $ map show $ map (first (fmap NameWithRange))@body.touchables) $ map snd @body.touchables
        loc . solveResults = constructErrors $ runFreshM $ solve [] [] [] @tyvars

SEM Body
    | Body
        declarations . bindingGroups    = []
        lhs . toplevelTypes = M.map (monoTypeToTypeScheme.getMonoFromPoly.snd) @lhs.typeSignatures
        lhs . (
            touchables, 
            monos, 
            assumptions, 
            environment, 
            typeSignaturesCollect, 
            constraints, 
            betaUnique,
            substitutionCollect,
            typeErrors
        ) =
            let inputBDG = traceCShow showIBG (@declarations.assumptions, @declarations.constraints, @declarations.typeSignaturesCollect, @lhs.monos, @declarations.touchables, @declarations.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups

ATTR FunctionBinding FunctionBindings [ betasLeft : {[TyVar]} betaRight : TyVar | | name : Name numberOfPatterns : Integer  ]

SEM Declaration
    | FunctionBindings
        lhs . bindingGroups     = [@bindingGroup]
        loc . bindingGroup      = (@environment, @assumptions, @constraints)
        lhs . toplevelTypes     = M.singleton (@bindings.name) (maybe @err monoTypeToTypeScheme $ lookup @beta @lhs.substitution)
        loc . environment       = M.singleton @bindings.name @beta
        loc . assumptions       = @bindings.assumptions
        lhs . touchables        = (Just @bindings.name, @beta) : (Nothing, @br) : map (\x -> (Nothing,x)) @bls ++ @bindings.touchables
        loc . constraints       = @parameterCons ++ @bindings.constraints 
        loc . bls               = take (fromInteger @bindings.numberOfPatterns) (map integer2Name [(@lhs.betaUnique + 2)..])
        loc . br                = integer2Name $ @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . parameterCons     = [Constraint_Unify (var @beta) (foldr ((:-->:) . var) (var @br) @bls)] --++
                                    --maybe [] (\ts -> [Constraint_Unify (var @beta) (fst $ freshen (9999 :: Integer) $ getMonoFromPoly ts)]) (M.lookup @bindings.name @lhs.typeSignatures)
        loc . err               = internalError "TypeInferenceRules.ag" "FunctionBindings" ("No substitution found for " ++ show @bindings.name)
        bindings.betasLeft      = @bls 
        bindings.betaRight      = @br 
        bindings . betaUnique   = @lhs.betaUnique + 2 + @bindings.numberOfPatterns
    | PatternBinding
        lhs . bindingGroups     = [@bindingGroup]
        loc . bindingGroup      = (@environment, @assumptions, @constraints)
        lhs . toplevelTypes     = M.fromList $ map (\(n, v) -> (n, monoTypeToTypeScheme $ substitutePoly v @lhs.substitution)) $ M.toList @pattern.environment
        lhs . touchables        = (Nothing, @beta) : @pattern.touchables ++ @righthandside.touchables
        loc . constraints       = [unifyVar @beta @pattern.beta, unifyVar @beta @righthandside.beta] ++ @pattern.constraints ++ @righthandside.constraints
        loc . environment       = @pattern.environment
        loc . assumptions       = @righthandside.assumptions
        pattern . betaUnique    = @lhs.betaUnique + 1 
        loc . beta              = integer2Name @lhs.betaUnique
        loc . err               = internalError "TypeInferenceRules.ag" "PatternBinding" "No substitution found for type"
    | TypeSignature
        lhs . touchables        = (Nothing, @beta) : map (\(x, _) -> (Nothing, x)) (M.elems @ts) -- ++ concatMap (getTypeVariablesFromMonoType . getMonoFromPoly . snd) @ts
        loc . beta              = integer2Name @lhs.betaUnique
        lhs . betaUnique        = @bu
--        lhs . environment       = @ts
        lhs . typeSignaturesCollect = @ts
        loc . (ts, bu)          = foldr (\n (m, b) -> let 
                                                (t, b') = typeToPolytype b @type.self
                                                m' = M.insert n (integer2Name b', t) m
                                            in (m', b' + 1)) (M.empty, @lhs.betaUnique + 1) $ @names.self

ATTR Pattern    [ | | beta : TyVar ]
ATTR Patterns   [ | | betas : {[TyVar]} numberOfPatterns:Integer ]


SEM Patterns
  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . numberOfPatterns = 1 + @tl.numberOfPatterns
  | Nil
      lhs . betas            = []
          . numberOfPatterns = 0
SEM Pattern
    | Variable
        lhs . touchables    = [(Just @name.self, @beta)]
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . environment   = M.singleton @name.self @beta
        loc . beta          = integer2Name @lhs.betaUnique
    | Literal
        lhs . touchables    = [(Nothing, @beta)]
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType]
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
    | Tuple
        patterns    . betaUnique        = @lhs.betaUnique + 1
        lhs         . constraints       = @constraint : @patterns.constraints
        lhs         . touchables        = (Nothing, @beta) : @patterns.touchables
        loc         . beta              = integer2Name @lhs.betaUnique
                    . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @patterns.betas))
    | Wildcard
        lhs         . touchables        = [(Nothing, @beta)]
        lhs         . betaUnique        = @lhs.betaUnique + 1
        loc         . beta              = integer2Name @lhs.betaUnique
    | List 
        lhs         . touchables        = (Nothing, @beta) : (Nothing, @elemBeta) : @patterns.touchables
        lhs         . constraints       = @lstConstraints ++ @patterns.constraints
        patterns    . betaUnique        = @lhs.betaUnique + 2
        loc         . beta              = integer2Name @lhs.betaUnique
        loc         . elemBeta          = integer2Name (@lhs.betaUnique + 1)
        loc         . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) : map (unifyVar @elemBeta) @patterns.betas
    | Constructor
        patterns    . betaUnique        = @lhs.betaUnique + 2
        lhs . touchables                = (Just @name.self, @beta) : (Just @name.self, @betaCon) : @patterns.touchables
        lhs . constraints               = @conApply : @conConstraints ++ @patterns.constraints
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . betaCon                   = integer2Name (@lhs.betaUnique + 1)
        loc . conApply                  = Constraint_Unify (var @betaCon) (foldr (:-->:) (var @beta) (map var @patterns.betas))
        loc . conConstraints            = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                                Nothing  -> []
                                                Just ctp -> [Constraint_Inst (var @betaCon) (PolyType_Mono [] $ tpSchemeToMonoType ctp)]
    | As
        pattern . betaUnique            = @lhs.betaUnique + 1
        lhs . touchables                = (Just @name.self, @beta) : @pattern.touchables
        lhs . constraints               = unifyVar @beta @pattern.beta : @pattern.constraints
        lhs . environment               = M.insert @name.self @beta @pattern.environment
        loc . beta                      = integer2Name @lhs.betaUnique

        
SEM FunctionBinding 
    | FunctionBinding
        lhs . constraints       = @locConstraints ++ @lefthandside.constraints ++ @righthandside.constraints
        lhs . name              = @lefthandside.name
        lhs . numberOfPatterns  = @lefthandside.numberOfPatterns
        lhs . assumptions       = @righthandside.assumptions M.\\ @lefthandside.environment
        loc . locConstraints    = Constraint_Unify (var @lhs.betaRight) (var @righthandside.beta) : 
                                    zipWith (\bt bb -> Constraint_Unify (var bt) (var bb)) @lhs.betasLeft @lefthandside.betas ++
                                    (concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Unify (var a') (var e) | (_, a') <- a]) @righthandside.assumptions @lefthandside.environment)
        

SEM FunctionBindings

  | Cons
        lhs . numberOfPatterns  = @hd.numberOfPatterns
            . name              = @hd.name
  | Nil
        lhs . numberOfPatterns  = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
            . name              = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"


ATTR LeftHandSide   [ | | name : {Name} betas : {[TyVar]} numberOfPatterns:Integer ]

SEM LeftHandSide
    | Function
        lhs . betas             = @patterns.betas
        lhs . numberOfPatterns  = @patterns.numberOfPatterns
        lhs . name              = @name.self

ATTR RightHandSide  [ | | beta : TyVar]

SEM RightHandSide
    | Expression
        lhs . beta = @expression.beta

ATTR Expression [ | | beta : TyVar]
ATTR Expressions [ | | betas : {[TyVar]} nrOfExpressions : Integer]

SEM Expressions
    | Cons
        lhs . betas = @hd.beta : @tl.betas
        lhs . nrOfExpressions = @tl.nrOfExpressions + 1
    | Nil 
        lhs . betas = []
        lhs . nrOfExpressions = 0


SEM Expression
    | Literal
        lhs . betaUnique    = @lhs.betaUnique + 1
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType]
        lhs . touchables    = [(Nothing, @beta)]
    | Variable
        lhs . touchables    = [(Just @name.self, @beta)]
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . assumptions   = M.singleton @name.self [(@name.self, @beta)]
    | NormalApplication
        loc . beta              = integer2Name @lhs.betaUnique
        function . betaUnique   = @lhs.betaUnique + 1
        lhs . touchables        = [(Nothing, @beta)] ++ @function.touchables ++ @arguments.touchables
        lhs . constraints       = [@constraint] ++ @function.constraints ++ @arguments.constraints
        loc . constraint        = Constraint_Unify (var @function.beta) (foldr (:-->:) (var @beta) (map var @arguments.betas))
    | If
        lhs . constraints       = @constraints ++ concat [@guardExpression.constraints, @thenExpression.constraints, @elseExpression.constraints]
        lhs . touchables        = (Nothing, @beta) : concat [@guardExpression.touchables, @thenExpression.touchables, @elseExpression.touchables]
        guardExpression.betaUnique = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . constraints       =   [
                                        Constraint_Unify (var @guardExpression.beta) (MonoType_Con "Bool" []),
                                        unifyVar @beta @thenExpression.beta,
                                        unifyVar @beta @elseExpression.beta 
                                    ]
    | Lambda
        lhs . touchables        = [(Nothing, @beta)] ++ @expression.touchables ++ @patterns.touchables
        lhs . constraints       = @fConstraint : @envConstraints ++ @expression.constraints ++ @patterns.constraints
        lhs . assumptions       = @expression.assumptions M.\\ @patterns.environment
        loc . envConstraints    = concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Unify (var a') (var e) | (_, a') <- a]) @expression.assumptions @patterns.environment
        patterns . betaUnique   = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . fConstraint       = Constraint_Unify (foldr ((:-->:).var) (var @expression.beta) @patterns.betas) (var @beta)
    | Tuple
        lhs . touchables        = (Nothing, @beta) : @expressions.touchables
        lhs . constraints       = @constraint : @expressions.constraints
        loc . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @expressions.betas))
        loc . beta              = integer2Name @lhs.betaUnique
        expressions . betaUnique = @lhs.betaUnique + 1
    | List
        lhs . touchables        = (Nothing, @elemBeta) : (Nothing, @beta) : @expressions.touchables
        lhs . constraints       = @lstConstraints ++ @expressions.constraints
        expressions . betaUnique = @lhs.betaUnique + 2
        loc . elemBeta          = integer2Name @lhs.betaUnique
        loc . beta              = integer2Name (@lhs.betaUnique + 1)
        loc . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) : map (unifyVar @elemBeta) @expressions.betas
    | Constructor
        lhs . touchables        = (Just @name.self, @beta) : (map (\x -> (Nothing, x)) $ getTypeVariablesFromMonoType @tp)
        lhs . betaUnique        = @bu
        loc . (tp, bu)          = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                    Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                    Just ctp -> freshen (@lhs.betaUnique + 1) (tpSchemeToMonoType ctp)
        lhs . constraints       = [Constraint_Inst (var @beta) (PolyType_Mono [] @tp)]
        loc . beta              = integer2Name @lhs.betaUnique
    | Let
        declarations.betaUnique = @lhs.betaUnique + 1
        lhs . betaUnique        = @bu
        lhs . touchables        = (Nothing, @beta) : @touchables
        lhs . constraints       = unifyVar @beta @expression.beta : @c
        lhs . bindingGroups     = []
        loc . beta              = integer2Name @lhs.betaUnique
        loc . (
            touchables, 
            monos, 
            assumptions, 
            environment, 
            typeSignaturesCollect, 
            c, 
            bu,
            sc,
            typeErrors
        ) =
            let inputBDG = traceCShow showIBG (@expression.assumptions, @expression.constraints, @declarations.typeSignaturesCollect, [], @declarations.touchables ++ @expression.touchables, @expression.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups



ATTR Literal [ | | literalType : MonoType]

SEM Literal
    | Int
        lhs . literalType   = MonoType_Con "Int" []
    | Float
        lhs . literalType   = MonoType_Con "Float" []
    | String
        lhs . literalType   = MonoType_Con "String" []
    | Char
        lhs . literalType   = MonoType_Con "Char" []
              
{

}

