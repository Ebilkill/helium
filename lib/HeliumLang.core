{- The (type) constructors and functions in this module are
   used in the translation of language constructs.
-} 

module HeliumLang where

import ( IridiumLang, LvmLang, LvmException )


{----------------------------------------------------------
  Fixities
----------------------------------------------------------}
custom infix (:) : export [5,"right"]

{--------------------------------------------------------------------------
  Built into the language
--------------------------------------------------------------------------}

{----------------------------------------------------------
  Basic data types
----------------------------------------------------------}
data '':->'' v$0 v$1

''$primPackedToString'' :: String -> String
''$primPackedToString'' : export = \p: (String) -> p

''$primUnsafePerformIO'' :: forall v$0. IO v$0 -> v$0
''$primUnsafePerformIO'' : export = forall v$0. \io: (IO v$0) -> unsafePerformIO {v$0} io

''$primPatternFailPacked'' :: forall v$0. String -> v$0
''$primPatternFailPacked'' : export = forall v$0. \p: (String) -> patternFailPacked {v$0} p

''$primErrorPacked'' :: forall v$0. String -> v$0
''$primErrorPacked'' : export = forall v$0. \p: (String) -> errorPacked {v$0} p

''$primConcat'' :: forall v$0. [[v$0]] -> [v$0]
''$primConcat'' : export = forall v$0. \ !xss: ([[v$0]]) ->
    case xss of 
    {   '':[]'' {[v$0]} -> [] {v$0}
    ;   (:) {[v$0]} ys yss -> ''$primAppend'' {v$0} ys (''$primConcat'' {v$0} yss)
    }

''$primConcatMap'' :: forall v$0. forall v$1. (v$0 -> [v$1]) -> ([v$0]) -> [v$1]
''$primConcatMap'' : export = forall v$0. forall v$1. \f: (v$0 -> [v$1]) -> \ !xs: ([v$0]) ->
    case xs of
    {   '':[]'' {v$0}  -> [] {v$1}
    ;   (:) {v$0} y ys -> ''$primAppend'' {v$1} (f y) (''$primConcatMap'' {v$0} {v$1} f ys)
    }
    
''$primAppend'' :: forall v$0. [v$0] -> [v$0] -> [v$0] -- is '++'
''$primAppend'' : export = forall v$0. \ !xs: ([v$0]) -> \ys: ([v$0]) ->
    case xs of 
    {   '':[]'' { v$0 } -> ys
    ;   (:) {v$0} z zs -> (:) {v$0} z (''$primAppend'' {v$0} zs ys)
    }

-- Show

showBool :: Bool -> String
showBool : export = \ !b: (Bool) ->
    case b of
    {   True -> "True"
    ;   default -> "False"
    }

showChar :: Char -> String
showChar : export = \c: (Char) ->
    (:) {Char} '\'' (''$primAppend'' {Char} (safeShowChar True c) 
                         "\'")

safeShowChar :: Bool -> Char -> String
safeShowChar = \ !inChar: (Bool) -> \ !c: (Char) -> case c of
    { '\a' -> "\\a"
    ; '\b' -> "\\b"
    ; '\f' -> "\\f"
    ; '\n' -> "\\n"
    ; '\r' -> "\\r"
    ; '\t' -> "\\t"
    ; '\\' -> "\\\\"
    ; '\'' -> case inChar of { True -> "\\'"
                             ; default -> (:) { Char } c ([] { Char })
                             }
    ; '\"' -> case inChar of { True -> (:) { Char } c ([] { Char })
                             ; default -> "\\\""
                             }
    ; default -> 
        let! cInt: (Int) = ''$primCharToInt'' c in
        let! geq32: (Bool) = (>=#) cInt 32 in case geq32 of
        {   True -> let! lt127: (Bool) = (<#) cInt 127 in case lt127 of
            {   True -> (:) { Char } c ([] { Char })
            ;   default -> (:) {Char} '\\' (showInt cInt)
            }
        ;   default -> (:) {Char} '\\' (showInt cInt)
        }
    }

showInt :: Int -> String
showInt : export = \ !n: (Int) ->
    let! isNeg: (Bool) = (<#) n 0 in case isNeg of
    {   True -> (:) {Char} '(' ((:) {Char} '-' 
                    (''$primAppend'' {Char}
                        (showPositiveInt (negInt n)) 
                        (stringFromPacked ")")
                    ))
    ;   default -> showPositiveInt n
    } 

showPositiveInt :: Int -> String
showPositiveInt = \i: (Int) ->
    let! rest: (Int) = quot i 10
    in let! digitInt: (Int) = (+#) 48 (rem i 10) -- 48 is '0'
    in let! digit: (Char) = ''$primIntToChar'' digitInt
    in let! digits: ([Char]) = (:) {Char} digit ('':[]'' {Char})
    in let! done: (Bool) = (==#) rest 0
    in
        case done of
        {   True -> digits
        ;   default -> ''$primAppend'' {Char} (showPositiveInt rest) digits
        }

