module IridiumLang
import (IridiumLangEval, IridiumLangString)

#[decl @origin [name @IridiumLang]]
export_as @_$helium_runtime_error from IridiumLangString declare @_$helium_runtime_error[1]: { forall a. [Char] -> a }
#[decl @origin [name @IridiumLang]]
export_as @_$helium_runtime_print_string from IridiumLangString declare @_$helium_runtime_print_string[1]: { ![Char] -> Int }

#[decl @kind [bytes "* -> *"]]
#[decl @origin [name @IridiumLang]]
export_as @"[]" data @"[]" {
  #[link @"[]" @data]
  #[decl @origin [name @IridiumLang]]
  export_as @"[]" constructor @"[]": { forall a. [a] } <>

  #[link @"[]" @data]
  #[decl @origin [name @IridiumLang]]
  export_as @":" constructor @":": { forall a. a -> [a] -> [a] } <>
}

#[decl @kind [bytes "*"]]
#[decl @origin [name @IridiumLang]]
export_as @Bool data @Bool {
  #[link @Bool @data]
  #[decl @origin [name @IridiumLang]]
  export_as @False constructor @False: { Bool } <>

  #[link @Bool @data]
  #[decl @origin [name @IridiumLang]]
  export_as @True constructor @True: { Bool } <>
}

#[decl @kind [bytes "*"]]
#[decl @origin [name @IridiumLang]]
export_as @Char data @Char {}

#[decl @kind [bytes "*"]]
#[decl @origin [name @IridiumLang]]
export_as @Int data @Int {}

#[decl @kind [bytes "*"]]
#[decl @origin [name @IridiumLang]]
export_as @Float data @Float {}

export_as @String type @String = { [Char] }

#[decl @origin [name @IridiumLang]]
export_as @primAddInt define @IridiumLang#primAddInt(%a: !Int, %b: !Int): Int = prim int_add(%a: !Int, %b: !Int)
#[decl @origin [name @IridiumLang]]
export_as @primSubInt define @IridiumLang#primSubInt(%a: !Int, %b: !Int): Int = prim int_sub(%a: !Int, %b: !Int)
#[decl @origin [name @IridiumLang]]
export_as @primMulInt define @IridiumLang#primMulInt(%a: !Int, %b: !Int): Int = prim int_mul(%a: !Int, %b: !Int)
#[decl @origin [name @IridiumLang]]
export_as @primQuotInt define @IridiumLang#primQuotInt(%a: !Int, %b: !Int): Int = prim int_sdiv(%a: !Int, %b: !Int)
#[decl @origin [name @IridiumLang]]
export_as @primRemInt define @IridiumLang#primRemInt(%a: !Int, %b: !Int): Int = prim int_srem(%a: !Int, %b: !Int)

#[decl @origin [name @IridiumLang]]
export_as @primAndInt define @IridiumLang#primAndInt(%a: !Int, %b: !Int): Int = prim int_and(%a: !Int, %b: !Int)
#[decl @origin [name @IridiumLang]]
export_as @primOrInt define @IridiumLang#primOrInt(%a: !Int, %b: !Int): Int = prim int_or(%a: !Int, %b: !Int)
#[decl @origin [name @IridiumLang]]
export_as @primXorInt define @IridiumLang#primXorInt(%a: !Int, %b: !Int): Int = prim int_xor(%a: !Int, %b: !Int)
#[decl @origin [name @IridiumLang]]
export_as @primShrInt define @IridiumLang#primShrInt(%a: !Int, %b: !Int): Int = prim int_ashr(%a: !Int, %b: !Int)
#[decl @origin [name @IridiumLang]]
export_as @primShrNat define @IridiumLang#primShrNat(%a: !Int, %b: !Int): Int = prim int_lshr(%a: !Int, %b: !Int)
#[decl @origin [name @IridiumLang]]
export_as @primShlInt define @IridiumLang#primShlInt(%a: !Int, %b: !Int): Int = prim int_shl(%a: !Int, %b: !Int)

#[decl @origin [name @IridiumLang]]
export_as @primNegInt define @IridiumLang#primNegInt(%a: !Int): Int {
entry:
  %0 = literal int 0
  %result = prim int_sub(%0: !Int, %a: !Int)
  return %result: !Int
}

#[decl @origin [name @IridiumLang]]
export_as @primEqInt define @IridiumLang#primEqInt(%a: !Int, %b: !Int): Bool {
entry:
  letalloc %true = constructor @True: Bool $ ()
  letalloc %false = constructor @False: Bool $ ()
  %result = prim int_eq({ !Bool }, %a: !Int, %b: !Int, %true: !Bool, %false: !Bool)
  return %result: !Bool
}

#[decl @origin [name @IridiumLang]]
export_as @primNeInt define @IridiumLang#primNeInt(%a: !Int, %b: !Int): Bool {
entry:
  letalloc %true = constructor @True: Bool $ ()
  letalloc %false = constructor @False: Bool $ ()
  %result = prim int_eq({ !Bool }, %a: !Int, %b: !Int, %false: !Bool, %true: !Bool)
  return %result: !Bool
}

#[decl @origin [name @IridiumLang]]
export_as @primLtInt define @IridiumLang#primLtInt(%a: !Int, %b: !Int): Bool {
entry:
  letalloc %true = constructor @True: Bool $ ()
  letalloc %false = constructor @False: Bool $ ()
  %result = prim int_slt({ !Bool }, %a: !Int, %b: !Int, %true: !Bool, %false: !Bool)
  return %result: !Bool
}

#[decl @origin [name @IridiumLang]]
export_as @primGeInt define @IridiumLang#primGeInt(%a: !Int, %b: !Int): Bool { ; a >= b <=> not(a < b)
entry:
  letalloc %true = constructor @True: Bool $ ()
  letalloc %false = constructor @False: Bool $ ()
  %result = prim int_slt({ !Bool }, %a: !Int, %b: !Int, %false: !Bool, %true: !Bool)
  return %result: !Bool
}

#[decl @origin [name @IridiumLang]]
export_as @primLeInt define @IridiumLang#primLeInt(%a: !Int, %b: !Int): Bool {
entry:
  %result = call @primGeInt[2]: (Int -> Int -> Bool) $ (%b: !Int, %a: !Int)
  return %result: !Bool
}
#[decl @origin [name @IridiumLang]]
export_as @primGtInt define @IridiumLang#primGtInt(%a: !Int, %b: !Int): Bool = call @primLtInt[2]: (Int -> Int -> Bool) $ (%b: !Int, %a: !Int)

#[decl @origin [name @IridiumLang]]
export_as @primAddFloat define @IridiumLang#primAddFloat(%a: !Float, %b: !Float): Float = prim float64_add(%a: !Float, %b: !Float)
#[decl @origin [name @IridiumLang]]
export_as @primSubFloat define @IridiumLang#primSubFloat(%a: !Float, %b: !Float): Float = prim float64_sub(%a: !Float, %b: !Float)
#[decl @origin [name @IridiumLang]]
export_as @primMulFloat define @IridiumLang#primMulFloat(%a: !Float, %b: !Float): Float = prim float64_mul(%a: !Float, %b: !Float)
#[decl @origin [name @IridiumLang]]
export_as @primDivFloat define @IridiumLang#primDivFloat(%a: !Float, %b: !Float): Float = prim float64_div(%a: !Float, %b: !Float)

#[decl @origin [name @IridiumLang]]
export_as @primNegFloat define @IridiumLang#primNegFloat(%a: !Float): Float {
entry:
  %0 = literal float64 0
  %result = prim float64_sub(%0: !Float, %a: !Float)
  return %result: !Float
}

#[decl @origin [name @IridiumLang]]
export_as @primEqFloat define @IridiumLang#primEqFloat(%a: !Float, %b: !Float): Bool {
entry:
  letalloc %true = constructor @True: Bool $ ()
  letalloc %false = constructor @False: Bool $ ()
  %result = prim float64_eq({!Bool}, %a: !Float, %b: !Float, %true: !Bool, %false: !Bool)
  return %result: !Bool
}

#[decl @origin [name @IridiumLang]]
export_as @primNeFloat define @IridiumLang#primNeFloat(%a: !Float, %b: !Float): Bool {
entry:
  letalloc %true = constructor @True: Bool $ ()
  letalloc %false = constructor @False: Bool $ ()
  %result = prim float64_ne({ !Bool }, %a: !Float, %b: !Float, %true: !Bool, %false: !Bool)
  return %result: !Bool
}

#[decl @origin [name @IridiumLang]]
export_as @primLtFloat define @IridiumLang#primLtFloat(%a: !Float, %b: !Float): Bool {
entry:
  letalloc %true = constructor @True: Bool $ ()
  letalloc %false = constructor @False: Bool $ ()
  %result = prim float64_lt({ !Bool }, %a: !Float, %b: !Float, %true: !Bool, %false: !Bool)
  return %result: !Bool
}

#[decl @origin [name @IridiumLang]]
export_as @primGtFloat define @IridiumLang#primGtFloat(%a: !Float, %b: !Float): Bool {
entry:
  letalloc %true = constructor @True: Bool $ ()
  letalloc %false = constructor @False: Bool $ ()
  %result = prim float64_gt({ !Bool }, %a: !Float, %b: !Float, %true: !Bool, %false: !Bool)
  return %result: !Bool
}

#[decl @origin [name @IridiumLang]]
export_as @primLeFloat define @IridiumLang#primLeFloat(%a: !Float, %b: !Float): Bool {
entry:
  letalloc %true = constructor @True: Bool $ ()
  letalloc %false = constructor @False: Bool $ ()
  %result = prim float64_le({ !Bool }, %a: !Float, %b: !Float, %true: !Bool, %false: !Bool)
  return %result: !Bool
}

#[decl @origin [name @IridiumLang]]
export_as @primGeFloat define @IridiumLang#primGeFloat(%a: !Float, %b: !Float): Bool {
entry:
  letalloc %true = constructor @True: Bool $ ()
  letalloc %false = constructor @False: Bool $ ()
  %result = prim float64_ge({ !Bool }, %a: !Float, %b: !Float, %true: !Bool, %false: !Bool)
  return %result: !Bool
}

#[decl @origin [name @IridiumLang]]
export_as @seq define @IridiumLang#seq(forall a, forall b, %a: !a, %b: !b): b [trampoline] {
entry:
  %c = seq %a: !a, %b: !b
  return %c: !b
}

#[decl @origin [name @IridiumLang]]
export_as @pseq define @IridiumLang#pseq(forall a, forall b, %a: !a, %b: b): b [trampoline] {
entry:
  %c = seq %a: !a, %b: b
  %c_whnf = eval %c: b
  return %c_whnf: !b
}

; IO
; data IORes a = IORes a !RealWorld
#[decl @kind [bytes "* -> *"]]
#[decl @origin [name @IridiumLang]]
export_as @IORes data @IORes {
  #[link @"IORes" @data]
  #[decl @origin [name @IridiumLang]]
  export_as @IORes constructor @IORes: { forall a. a -> !RealWorld -> IORes a } <>
}

; data RealWorld
#[decl @kind [bytes "*"]]
#[decl @origin [name @IridiumLang]]
export_as @RealWorld data @RealWorld {}

; data IO a = IO !(RealWorld -> IORes a)
#[decl @kind [bytes "* -> *"]]
#[decl @origin [name @IridiumLang]]
export_as @IO data @IO {
  #[link @"IO" @data]
  #[decl @origin [name @IridiumLang]]
  export_as @IO constructor @"IO": { forall a. (RealWorld -> IORes a) -> IO a } <>
}

; unsafePerformIO :: IO a -> a
#[decl @origin [name @IridiumLang]]
export_as @unsafePerformIO define @IridiumLang#unsafePerformIO(forall a, %io: !(IO a)): a [trampoline] {
entry:
  match %io: !IO on @IO: (forall a. (RealWorld -> IORes a) -> IO a) { a } (%fn)
  %world = undefined !RealWorld
  letalloc %thunk = thunk %fn: (RealWorld -> IORes a) $ (%world: !RealWorld)
  %res = eval %thunk: (IORes a)
  match %res: !(IORes a) on @IORes: (forall a. a -> RealWorld -> IORes a) { a } (%value_any, %new_world)
  %value = eval %value_any: a
  %value2 = seq %new_world: RealWorld, %value: !a
  return %value2: !a
}

; $primPutChar :: Char -> RealWorld -> IORes Int
#[decl @origin [name @IridiumLang]]
export_as @$primPutChar declare @putchar[2]: { !Char -> !RealWorld -> IORes Int } [callconvention:c fake_io]

; $primGetChar :: RealWorld -> IORes Char
#[decl @origin [name @IridiumLang]]
export_as @$primGetChar declare @getchar[1]: { RealWorld -> IORes Char } [callconvention:c fake_io]

#[decl @origin [name @IridiumLang]]
export_as @$primIntToChar define @IridiumLang#$primIntToChar(%x: !Int): Char [trampoline] = prim int_to_char(%x: !Int)

#[decl @origin [name @IridiumLang]]
export_as @$primCharToInt define @IridiumLang#$primCharToInt(%x: !Char): Int [trampoline] = prim char_to_int(%x: !Int)
