module IridiumLang
import (IridiumLangEval, IridiumLangString)

export_as @_$helium_runtime_error from IridiumLangString declare @_$helium_runtime_error: (any) -> any_whnf
export_as @_$helium_runtime_print_string from IridiumLangString declare @_$helium_runtime_print_string: (@"[]") -> int

#[decl @kind [bytes "* -> *"]]
data @"[]" {
  #[decl @type [bytes "[a]"]]
  #[link @"[]" @data]
  constructor @"[]"()

  #[decl @type [bytes "a -> [a] -> [a]"]]
  #[link @"[]" @data]
  constructor @":"(any, any)
}

#[decl @kind [bytes "*"]]
export_as @Bool data @Bool {
  #[decl @type [bytes "Bool"]]
  #[link @Bool @data]
  export_as @False constructor @False()

  #[decl @type [bytes "Bool"]]
  #[link @Bool @data]
  export_as @True constructor @True()
}

#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primAddInt define @primAddInt(%a: int, %b: int) = prim int_add(%a: int, %b: int)
#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primSubInt define @primSubInt(%a: int, %b: int) = prim int_sub(%a: int, %b: int)
#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primMulInt define @primMulInt(%a: int, %b: int) = prim int_mul(%a: int, %b: int)
#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primQuotInt define @primQuotInt(%a: int, %b: int) = prim int_sdiv(%a: int, %b: int)
#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primRemInt define @primRemInt(%a: int, %b: int) = prim int_srem(%a: int, %b: int)
; TODO: Are div and mod (rounding to -inf) available in LLVM?

#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primAndInt define @primAndInt(%a: int, %b: int) = prim int_and(%a: int, %b: int)
#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primOrInt define @primOrInt(%a: int, %b: int) = prim int_or(%a: int, %b: int)
#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primXorInt define @primXorInt(%a: int, %b: int) = prim int_xor(%a: int, %b: int)
#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primShrInt define @primShrInt(%a: int, %b: int) = prim int_ashr(%a: int, %b: int)
#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primShrNat define @primShrNat(%a: int, %b: int) = prim int_lshr(%a: int, %b: int)
#[decl @iridiumtype [bytes "(int, int) -> int"]]
export_as @primShlInt define @primShlInt(%a: int, %b: int) = prim int_shl(%a: int, %b: int)

#[decl @iridiumtype [bytes "(int) -> int"]]
export_as @primNegInt define @primNegInt(%a: int): int {
entry:
  %0 = literal int 0
  %result = prim int_sub(%0: int, %a: int)
  return %result: int
}

#[decl @iridiumtype [bytes "(int, int) -> @Bool"]]
export_as @primEqInt define @primEqInt(%a: int, %b: int): @Bool {
entry:
  letalloc %true_ = constructor @True: () -> @Bool $ ()
  letalloc %false_ = constructor @False: () -> @Bool $ ()
  %true = cast %true_: @Bool as any_whnf
  %false = cast %false_: @Bool as any_whnf
  %result = prim int_eq(%a: int, %b: int, %true: any_whnf, %false: any_whnf)
  %result_ = cast %result: any_whnf as @Bool
  return %result_: @Bool
}

#[decl @iridiumtype [bytes "(int, int) -> @Bool"]]
export_as @primNeInt define @primNeInt(%a: int, %b: int): @Bool {
entry:
  letalloc %true_ = constructor @True: () -> @Bool $ ()
  letalloc %false_ = constructor @False: () -> @Bool $ ()
  %true = cast %true_: @Bool as any_whnf
  %false = cast %false_: @Bool as any_whnf
  %result = prim int_eq(%a: int, %b: int, %false: any_whnf, %true: any_whnf)
  %result_ = cast %result: any_whnf as @Bool
  return %result_: @Bool
}

#[decl @iridiumtype [bytes "(int, int) -> @Bool"]]
export_as @primLtInt define @primLtInt(%a: int, %b: int): @Bool {
entry:
  letalloc %true_ = constructor @True: () -> @Bool $ ()
  letalloc %false_ = constructor @False: () -> @Bool $ ()
  %true = cast %true_: @Bool as any_whnf
  %false = cast %false_: @Bool as any_whnf
  %result = prim int_slt(%a: int, %b: int, %true: any_whnf, %false: any_whnf)
  %result_ = cast %result: any_whnf as @Bool
  return %result_: @Bool
}

#[decl @iridiumtype [bytes "(int, int) -> @Bool"]]
export_as @primGeInt define @primGeInt(%a: int, %b: int): @Bool { ; a >= b <=> not(a < b)
entry:
  letalloc %true_ = constructor @True: () -> @Bool $ ()
  letalloc %false_ = constructor @False: () -> @Bool $ ()
  %true = cast %true_: @Bool as any_whnf
  %false = cast %false_: @Bool as any_whnf
  %result = prim int_slt(%a: int, %b: int, %false: any_whnf, %true: any_whnf)
  %result_ = cast %result: any_whnf as @Bool
  return %result_: @Bool
}

#[decl @iridiumtype [bytes "(int, int) -> @Bool"]]
export_as @primLeInt define @primLeInt(%a: int, %b: int) = call @primGeInt: (int, int) -> @Bool $ (%b: int, %a: int)
#[decl @iridiumtype [bytes "(int, int) -> @Bool"]]
export_as @primGtInt define @primGtInt(%a: int, %b: int) = call @primLtInt: (int, int) -> @Bool $ (%b: int, %a: int)

#[decl @iridiumtype [bytes "(float64, float64) -> float64"]]
export_as @primAddFloat define @primAddFloat(%a: float64, %b: float64) = prim float64_add(%a: float64, %b: float64)
#[decl @iridiumtype [bytes "(float64, float64) -> float64"]]
export_as @primSubFloat define @primSubFloat(%a: float64, %b: float64) = prim float64_sub(%a: float64, %b: float64)
#[decl @iridiumtype [bytes "(float64, float64) -> float64"]]
export_as @primMulFloat define @primMulFloat(%a: float64, %b: float64) = prim float64_mul(%a: float64, %b: float64)
#[decl @iridiumtype [bytes "(float64, float64) -> float64"]]
export_as @primDivFloat define @primDivFloat(%a: float64, %b: float64) = prim float64_div(%a: float64, %b: float64)

#[decl @iridiumtype [bytes "(float64) -> float64"]]
export_as @primNegFloat define @primNegFloat(%a: float64): float64 {
entry:
  %0 = literal float64 0
  %result = prim float64_sub(%0: float64, %a: float64)
  return %result: float64
}

#[decl @iridiumtype [bytes "(float64, float64) -> @Bool"]]
export_as @primEqFloat define @primEqFloat(%a: float64, %b: float64): @Bool {
entry:
  letalloc %true_ = constructor @True: () -> @Bool $ ()
  letalloc %false_ = constructor @False: () -> @Bool $ ()
  %true = cast %true_: @Bool as any_whnf
  %false = cast %false_: @Bool as any_whnf
  %result = prim float64_eq(%a: float64, %b: float64, %true: any_whnf, %false: any_whnf)
  %result_ = cast %result: any_whnf as @Bool
  return %result_: @Bool
}

#[decl @iridiumtype [bytes "(float64, float64) -> @Bool"]]
export_as @primNeFloat define @primNeFloat(%a: float64, %b: float64): @Bool {
entry:
  letalloc %true_ = constructor @True: () -> @Bool $ ()
  letalloc %false_ = constructor @False: () -> @Bool $ ()
  %true = cast %true_: @Bool as any_whnf
  %false = cast %false_: @Bool as any_whnf
  %result = prim float64_ne(%a: float64, %b: float64, %true: any_whnf, %false: any_whnf)
  %result_ = cast %result: any_whnf as @Bool
  return %result_: @Bool
}

#[decl @iridiumtype [bytes "(float64, float64) -> @Bool"]]
export_as @primLtFloat define @primLtFloat(%a: float64, %b: float64): @Bool {
entry:
  letalloc %true_ = constructor @True: () -> @Bool $ ()
  letalloc %false_ = constructor @False: () -> @Bool $ ()
  %true = cast %true_: @Bool as any_whnf
  %false = cast %false_: @Bool as any_whnf
  %result = prim float64_lt(%a: float64, %b: float64, %true: any_whnf, %false: any_whnf)
  %result_ = cast %result: any_whnf as @Bool
  return %result_: @Bool
}

#[decl @iridiumtype [bytes "(float64, float64) -> @Bool"]]
export_as @primGtFloat define @primGtFloat(%a: float64, %b: float64): @Bool {
entry:
  letalloc %true_ = constructor @True: () -> @Bool $ ()
  letalloc %false_ = constructor @False: () -> @Bool $ ()
  %true = cast %true_: @Bool as any_whnf
  %false = cast %false_: @Bool as any_whnf
  %result = prim float64_gt(%a: float64, %b: float64, %true: any_whnf, %false: any_whnf)
  %result_ = cast %result: any_whnf as @Bool
  return %result_: @Bool
}

#[decl @iridiumtype [bytes "(float64, float64) -> @Bool"]]
export_as @primLeFloat define @primLeFloat(%a: float64, %b: float64): @Bool {
entry:
  letalloc %true_ = constructor @True: () -> @Bool $ ()
  letalloc %false_ = constructor @False: () -> @Bool $ ()
  %true = cast %true_: @Bool as any_whnf
  %false = cast %false_: @Bool as any_whnf
  %result = prim float64_le(%a: float64, %b: float64, %true: any_whnf, %false: any_whnf)
  %result_ = cast %result: any_whnf as @Bool
  return %result_: @Bool
}

#[decl @iridiumtype [bytes "(float64, float64) -> @Bool"]]
export_as @primGeFloat define @primGeFloat(%a: float64, %b: float64): @Bool {
entry:
  letalloc %true_ = constructor @True: () -> @Bool $ ()
  letalloc %false_ = constructor @False: () -> @Bool $ ()
  %true = cast %true_: @Bool as any_whnf
  %false = cast %false_: @Bool as any_whnf
  %result = prim float64_ge(%a: float64, %b: float64, %true: any_whnf, %false: any_whnf)
  %result_ = cast %result: any_whnf as @Bool
  return %result_: @Bool
}

#[decl @type [bytes "a -> b -> b"]]
export_as @primSeq define @primSeq(%a: any, %b: any): any_whnf [trampoline] {
entry:
  %a_whnf = eval %a: any
  %b_whnf = eval %b: any
  %c = seq %a_whnf: any_whnf, %b_whnf: any_whnf
  return %c: any_whnf
}

#[decl @type [bytes "a -> b -> b"]]
export_as @primPseq define @primPseq(%a: any, %b: any): any_whnf [trampoline] {
entry:
  %a_whnf = eval %a: any
  %c = seq %a_whnf: any_whnf, %b: any
  %c_whnf = eval %c: any
  return %c_whnf: any_whnf
}

; IO
; data IORes a = IORes a !RealWorld
#[decl @kind [bytes "* -> *"]]
export_as @IORes data @IORes {
  #[decl @type [bytes "a -> RealWorld -> IORes a"]]
  #[link @"IORes" @data]
  export_as @IORes constructor @"IORes"(any, real_world)
}

; data IO a = IO !(!RealWorld -> IORes a)
#[decl @kind [bytes "* -> *"]]
export_as @IO data @IO {
  #[decl @type [bytes "(RealWorld -> IORes a) -> IO a"]]
  #[link @"IO" @data]
  export_as @IO constructor @"IO"(anyfunction)
}

; unsafePerformIO :: IO a -> a
#[decl @type [bytes "IO a -> a"]]
export_as @unsafePerformIO define @unsafePerformIO(%io: @IO): any_whnf [trampoline] {
entry:
  match %io: @IO on @IO: (anyfunction) -> @IO (%fn)
  %world = undefined real_world
  letalloc %thunk = thunk %fn: anyfunction $ (%world: real_world)
  %res_any = eval %thunk: any_thunk
  %res = cast %res_any: any_whnf as @IORes
  match %res: @IORes on @IORes: (any, real_world) -> @IORes (%value_any, %new_world)
  %value = eval %value_any: any
  %value2 = seq %new_world: real_world, %value: any_whnf
  return %value2: any_whnf
}

; $primPutChar :: Char -> RealWorld -> IORes
#[decl @type [bytes "Char -> RealWorld -> IORes"]]
export_as @$primPutChar declare @putchar: (int, real_world) -> @IORes [callconvention:c fake_io]

; $primPutChar :: RealWorld -> IORes
#[decl @type [bytes "RealWorld -> IORes"]]
export_as @$primGetChar declare @getchar: (real_world) -> @IORes [callconvention:c fake_io]
