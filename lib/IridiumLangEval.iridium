module IridiumLangEval
import ()

define @_$helium_runtime_concatThunk(%left: unsafeptr, %right: unsafeptr): any_thunk {
entry:
  %left_tag = prim thunk_extract_tag(%left: unsafeptr)

  %16 = literal int 16
  %left_remaining = prim int_lshr(%left_tag: int, %16: int)

  %argcount_mask = literal int 65535
  %left_arguments = prim int_and(%left_tag: int, %argcount_mask: int)

  match %right: unsafeptr on thunk 1 (_, %right_argument: any)

  ; New tag has one argument more (so tag += 1)
  ; and thus one less remaining (so tag -= 65536)
  %tag_diff = literal int 65535
  %newtag = prim int_sub(%left_tag: int, %tag_diff: int)

  case %left_arguments: int int ( 0 to 0, 1 to 1 ) otherwise unreachable

unreachable:
  unreachable

0:
  match %left: unsafeptr on thunk 0 (%0_target: unsafeptr)
  letalloc %0_res = function %0_target: unsafeptr $ (%right_argument: any)
  %0_unsafe = cast %0_res: any_whnf as unsafeptr
  %0_ = prim thunk_write_tag(%0_unsafe: unsafeptr, %newtag: int)
  return %0_res: any_thunk

1:
  match %left: unsafeptr on thunk 1 (%1_target: unsafeptr, %1_0: any)
  letalloc %1_res = function %1_target: unsafeptr $ (%1_0: any, %right_argument: any)
  %1_unsafe = cast %1_res: any_whnf as unsafeptr
  %1_ = prim thunk_write_tag(%1_unsafe: unsafeptr, %newtag: int)
  return %1_res: any_thunk

; TODO: Allow more than 1 argument
}


export define @_$helium_runtime_eval(%a: unsafeptr, %b: int): any_whnf {
eval.entry:
  case %b: int int ( 0 to eval.thunk) otherwise eval.whnf

eval.whnf:
  %a_as_whnf = cast %a: unsafeptr as any_whnf
  return %a_as_whnf: any_whnf

eval.thunk:
  %res = call @eval_thunk: (unsafeptr) -> any_whnf $ (%a: unsafeptr)
  return %res: any_whnf
}

export define @eval_thunk(%a: unsafeptr): any_whnf {
eval_thunk.entry:
  %tag = prim thunk_extract_tag(%a: unsafeptr)

  %16 = literal int 16
  %remaining = prim int_lshr(%tag: int, %16: int)

  %argcount_mask = literal int 65535
  %argcount = prim int_and(%tag: int, %argcount_mask: int)

  %target_ptr_offset = prim thunk_target_ptr_offset(%argcount: int)
  %target_ptr = prim unsafeptr_add(%a: unsafeptr, %target_ptr_offset: int)
  %target = prim unsafeptr_read(%target_ptr: unsafeptr)

  ; Precalculate tags that we might need later on
  %blackhole = literal int 65533
  %blackhole_shifted = prim int_shl(%blackhole: int, %16: int)
  %tag_blackhole = prim int_or(%blackhole_shifted: int, %argcount: int)

  %evaluated = literal int 65534
  %evaluated_shifted = prim int_shl(%evaluated: int, %16: int)
  %tag_evaluated = prim int_or(%evaluated_shifted: int, %argcount: int)

  case %remaining: int int ( 0 to eval.go, 65533 to eval.is_blackhole, 65534 to eval.is_evaluated, 65535 to eval.target_is_thunk ) otherwise eval.whnf

eval.whnf:
  %a_as_whnf = cast %a: unsafeptr as any_whnf
  return %a_as_whnf: any_whnf

eval.is_blackhole:
  %err_loop = literal str "Loop"
  %err_loop_any = cast %err_loop: @"[]" as any
  %_call = call @error: (any) -> any_whnf $ (%err_loop_any: any)
  unreachable

eval.is_evaluated:
  %target_as_whnf = cast %target: unsafeptr as any_whnf
  return %target_as_whnf: any_whnf

eval.target_is_thunk:
  ; Mark the thunk as a blackhole
  %_4 = prim thunk_write_tag(%a: unsafeptr, %tag_blackhole: int)

  %target_thunk_whnf = call @eval_thunk: (unsafeptr) -> any_whnf $ (%target: unsafeptr)
  %target_thunk = cast %target_thunk_whnf: any_whnf as unsafeptr
  %new_thunk = call @_$helium_runtime_concatThunk: (unsafeptr, unsafeptr) -> any_thunk $ (%target_thunk: unsafeptr, %a: unsafeptr)
  %new_thunk_unsafe = cast %new_thunk: any_thunk as unsafeptr
  %new_thunk_eval = call @eval_thunk: (unsafeptr) -> any_whnf $ (%new_thunk_unsafe: unsafeptr)
  
  ; Mark the thunk as evaluated
  %_5 = prim thunk_write_tag(%a: unsafeptr, %tag_evaluated: int)

  ; Store the result in the thunk
  %_6 = prim unsafeptr_write(%target_ptr: unsafeptr, %new_thunk_eval: any_whnf)

  return %new_thunk_eval: any_whnf

eval.go:
  ; Mark the thunk as a blackhole
  %_1 = prim thunk_write_tag(%a: unsafeptr, %tag_blackhole: int)

  ; Invoke the function
  %value = prim thunk_call(%target: unsafeptr, %a: unsafeptr)

  ; Mark the thunk as evaluated
  %_2 = prim thunk_write_tag(%a: unsafeptr, %tag_evaluated: int)

  ; Store the result in the thunk
  %_3 = prim unsafeptr_write(%target_ptr: unsafeptr, %value: any_whnf)

  return %value: any_whnf
}
