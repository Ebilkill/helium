----------------------------------------------------------------
-- Daan Leijen (c) 2001
--
-- $Revision$
-- $Author$
-- $Date$
----------------------------------------------------------------
module LvmLang
    ( Bytes, Int, Float
    , Bool(True, False), '':[]''('':[]'', (:)), '':()''('':()'')
    , IO(..), IORes(..), RealWorld(..), Char, Double, PackedString, String
    
    , packedFromString, stringFromPacked, packedLength
    , ($!), seq, pseq
    , ''$primUnsafeCast''

    -- IO
    , unsafePerformIO, unsafePerformStrictIO
    , ''$primPutStrLn''
    , putChar
    , getChar

    -- Int
    , (+#), (-#), (*#), div, mod, quot, rem
    , and, xor, or, shr, shl, shrNat, negInt
    , (==#), (/=#), (<#), (>#), (<=#), (>=#)
{-
    -- Float
    , (+.), (-.), (*.), (/.), negFloat
    , (==.), (/=.), (<.), (>.), (<=.), (>=.)
-}
    ) where

import IridiumLang

{----------------------------------------------------------
  Instructions
----------------------------------------------------------}
{- instruction primAddInt  "addint" :: Int! -> Int! -> Int!
instruction primSubInt  "subint" :: Int! -> Int! -> Int!
instruction primMulInt  "mulint" :: Int! -> Int! -> Int!
instruction primDivInt  "divint" :: Int! -> Int! -> Int!
instruction primModInt  "modint" :: Int! -> Int! -> Int!
instruction primQuotInt "quotint":: Int! -> Int! -> Int!
instruction primRemInt  "remint" :: Int! -> Int! -> Int!
instruction primAndInt  "andint" :: Int! -> Int! -> Int!
instruction primXorInt  "xorint" :: Int! -> Int! -> Int!
instruction primOrInt   "orint"  :: Int! -> Int! -> Int!
instruction primShrInt  "shrint" :: Int! -> Int! -> Int!
instruction primShlInt  "shlint" :: Int! -> Int! -> Int!
instruction primShrNat  "shrnat" :: Int! -> Int! -> Int!
instruction primNegInt  "negint" :: Int! -> Int!

instruction primEqInt   "eqint"  :: Int! -> Int! -> Bool!
instruction primNeInt   "neint"  :: Int! -> Int! -> Bool!
instruction primLtInt   "ltint"  :: Int! -> Int! -> Bool!
instruction primGtInt   "gtint"  :: Int! -> Int! -> Bool!
instruction primLeInt   "leint"  :: Int! -> Int! -> Bool!
instruction primGeInt   "geint"  :: Int! -> Int! -> Bool!

instruction primAddFloat  "addfloat" :: Float! -> Float! -> Float!
instruction primSubFloat  "subfloat" :: Float! -> Float! -> Float!
instruction primMulFloat  "mulfloat" :: Float! -> Float! -> Float!
instruction primDivFloat  "divfloat" :: Float! -> Float! -> Float!
instruction primNegFloat  "negfloat" :: Float! -> Float!

instruction primEqFloat   "eqfloat"  :: Float! -> Float! -> Bool!
instruction primNeFloat   "nefloat"  :: Float! -> Float! -> Bool!
instruction primLtFloat   "ltfloat"  :: Float! -> Float! -> Bool!
instruction primGtFloat   "gtfloat"  :: Float! -> Float! -> Bool!
instruction primLeFloat   "lefloat"  :: Float! -> Float! -> Bool!
instruction primGeFloat   "gefloat"  :: Float! -> Float! -> Bool!

instruction primAlloc   "alloc"  :: Int! {- tag -} -> Int! {- size -} -> a!
instruction primGetTag  "gettag" :: a! -> Int!
instruction primGetSize "getsize":: a! -> Int!
-- instruction primNew     "new"    :: Int! {- tag -} -> Int! {- size -} -> {- x_1 ... x_n -> -} a!
-- instruction primPack    "pack"   :: a! -> Int! {- size -} -> {- x_1 ... x_size -} ()
-- instruction primUnPack  "unpack" :: a! -> (# x_1 ... x_size #)

extern prim_chars_of_string :: "aa"
extern prim_string_of_chars :: "ala"
extern prim_string_length   :: "la"
-}

{----------------------------------------------------------
  Basic data types
----------------------------------------------------------}
data Bytes
data Int
data Float

-- data '':[]'' v$0 = '':[]'' | (:) v$0 [v$0]
-- data '':()''    = '':()''

{----------------------------------------------------------
  Type definitions
----------------------------------------------------------}
type Double       = Float

type PackedString = String
type String       = [Char] 

{----------------------------------------------------------
  Strictness
----------------------------------------------------------}
($!) :: forall v$0. forall v$1. (v$0 -> v$1) -> v$0 -> v$1
($!) = forall v$0. forall v$1. \f: (v$0 -> v$1) -> \x: v$0 -> let! x: v$0! = x in f x

seq :: forall v$0. forall v$1. v$0 -> v$1 -> v$1
seq = forall v$0. forall v$1. \a: v$0 -> \b: v$1 -> primSeq {v$0} {v$1} a b

pseq :: forall v$0. forall v$1. v$0 -> v$1 -> v$1
pseq = forall v$0. forall v$1. \a: v$0 -> \b: v$1 -> primPseq {v$0} {v$1} a b

{----------------------------------------------------------
  Basic arithmetic on Int's
----------------------------------------------------------}
(+#) :: Int -> Int -> Int
(+#) = \x: Int -> \y: Int -> primAddInt x y

(-#) :: Int -> Int -> Int
(-#) = \x: Int -> \y: Int -> primSubInt x y

(*#) :: Int -> Int -> Int
(*#) = \x: Int -> \y: Int -> primMulInt x y

-- TODO: Round to -inf instead of zero
div :: Int -> Int -> Int
div = \x: Int -> \y: Int -> quot x y -- primDivInt x y

-- TODO: Round to -inf instead of zero
mod :: Int -> Int -> Int
mod = \x: Int -> \y: Int -> rem x y -- primModInt x y

quot :: Int -> Int -> Int
quot = \x: Int -> \y: Int -> primQuotInt x y

rem :: Int -> Int -> Int
rem = \x: Int -> \y: Int -> primRemInt x y
{-
and :: Int -> Int -> Int
and = \x: Int -> \y: Int -> primAndInt x y

xor :: Int -> Int -> Int
xor = \x: Int -> \y: Int -> primXorInt x y

or :: Int -> Int -> Int
or = \x: Int -> \y: Int -> primOrInt x y
-}
shr :: Int -> Int -> Int
shr = \x: Int -> \y: Int -> primShrInt x y

shl :: Int -> Int -> Int
shl = \x: Int -> \y: Int -> primShlInt x y

shrNat :: Int -> Int -> Int
shrNat = \x: Int -> \y: Int -> primShrNat x y

negInt :: Int -> Int
negInt = \x: Int -> primNegInt x

{----------------------------------------------------------
  Comparisons on Int's
----------------------------------------------------------}
(==#) :: Int -> Int -> Bool
(==#) = \x: Int -> \y: Int -> primEqInt x y

(/=#) :: Int -> Int -> Bool
(/=#) = \x: Int -> \y: Int -> primNeInt x y

(<#) :: Int -> Int -> Bool
(<#) = \x: Int -> \y: Int -> primLtInt x y

(>#) :: Int -> Int -> Bool
(>#) = \x: Int -> \y: Int -> primGtInt x y

(<=#) :: Int -> Int -> Bool
(<=#) = \x: Int -> \y: Int -> primLeInt x y

(>=#) :: Int -> Int -> Bool
(>=#) = \x: Int -> \y: Int -> primGeInt x y

{----------------------------------------------------------
  Basic arithmetic on Float's
----------------------------------------------------------}

(+.) :: Float -> Float -> Float
(+.) = \x: Float -> \y: Float -> primAddFloat x y

(-.) :: Float -> Float -> Float
(-.) = \x: Float -> \y: Float -> primSubFloat x y

(*.) :: Float -> Float -> Float
(*.) = \x: Float -> \y: Float -> primMulFloat x y

(/.) :: Float -> Float -> Float
(/.) = \x: Float -> \y: Float -> primDivFloat x y

negFloat :: Float -> Float
negFloat = \x: Float -> primNegFloat x

{----------------------------------------------------------
  Comparisons on Float's
----------------------------------------------------------}

(==.) :: Float -> Float -> Bool
(==.) = \x: Float -> \y: Float -> primEqFloat x y

(/=.) :: Float -> Float -> Bool
(/=.) = \x: Float -> \y: Float -> primNeFloat x y

(<.) :: Float -> Float -> Bool
(<.) = \x: Float -> \y: Float -> primLtFloat x y

(>.) :: Float -> Float -> Bool
(>.) = \x: Float -> \y: Float -> primGtFloat x y

(<=.) :: Float -> Float -> Bool
(<=.) = \x: Float -> \y: Float -> primLeFloat x y

(>=.) :: Float -> Float -> Bool
(>=.) = \x: Float -> \y: Float -> primGeFloat x y

{----------------------------------------------------------
  Packed strings
----------------------------------------------------------}
stringFromPacked :: PackedString -> String
stringFromPacked = \p: String -> p

packedFromString :: String -> PackedString
packedFromString = \s: String -> s
  {- = let forced s = case s of
                     []       -> []
                     (:) x xs -> let! y  = x
                                      ys = forced xs
                                 in (:) y ys
        length n s = case s of
                       []       -> n
                       (:) x xs -> let! m = (+#) n 1
                                   in length m xs
    in let! fs  = forced s
            len = length 0 fs
       in prim_string_of_chars len fs -}
            
  
    {-
    let forceLength n xs = case xs of
                             (:) x xx -> seq x (forceLength ((+#) n 1) xx)
                             []       -> n 
    in let! len = forceLength 0 s 
            t   = s 
       in prim_string_of_chars len t
    -}

{- packedLength :: PackedString -> Int
packedLength s
  = let! s = s in prim_string_length s
-}
{----------------------------------------------------------
  List helpers
----------------------------------------------------------}
{-
length :: [a] -> Int
length xs
  = foldlStrict (+#) 0 xs

foldlStrict :: (b -> a -> b) -> b -> [a] -> b
foldlStrict f z xs
  = case xs of
      (:) x xx -> case f z x of
                    z -> foldlStrict f z xx
      []       -> z
-}

getChar :: IO Char
getChar = IO { Char } (\world: RealWorld -> ''$primGetChar'' world)

putChar :: Char -> IO ()
putChar = \char: Char -> IO { () }
  (\world: RealWorld -> let! res: IORes Int = ''$primPutChar'' char world in case res of
    IORes { Int } _ world2 -> IORes { () } () world2
  )

''$primPutStrLn'' :: String -> IO ()
''$primPutStrLn'' = \str: String ->
  let! newline: String! = "\n" in
  let! _1: Int! = ''_$helium_runtime_print_string'' str in
  let! _2: Int! = ''_$helium_runtime_print_string'' newline in
  IO {()} (\realworld: RealWorld! -> IORes {()} () realworld)
